<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Complexity Explorer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Chart.js for the visualizer -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Load MathJax to render LaTeX equations -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
          processEscapes: true,
        },
        startup: {
          ready: () => {
            MathJax.startup.defaultReady();
            MathJax.startup.promise.then(() => {
              console.log("MathJax all set!");
            });
          },
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>

    <style>
      /* Custom styles for a dark-mode app */
      body {
        font-family: "Inter", sans-serif;
        color: #e0e0e0;
      }
      .nav-link.active {
        background-color: #111827; /* gray-900 */
        color: #38bdf8; /* sky-400 */
      }
      /* Custom scrollbar for the main content area */
      .module-content {
        overflow-y: auto;
        max-height: 100vh;
      }
      .module-content::-webkit-scrollbar {
        width: 8px;
      }
      .module-content::-webkit-scrollbar-track {
        background: #1f2937; /* gray-800 */
      }
      .module-content::-webkit-scrollbar-thumb {
        background: #4b5563; /* gray-600 */
        border-radius: 4px;
      }
      .module-content::-webkit-scrollbar-thumb:hover {
        background: #6b7280; /* gray-500 */
      }

      /* Tab styles */
      .tab-btn {
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        background-color: #374151; /* gray-700 */
        color: #d1d5db; /* gray-300 */
        font-weight: 500;
        cursor: pointer;
      }
      .tab-btn.active {
        background-color: #38bdf8; /* sky-400 */
        color: #1e293b; /* gray-800 */
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }

      /* Popover/Details styles for Module 4 */
      details.popover-def {
        display: inline;
        cursor: pointer;
      }
      details.popover-def summary {
        display: inline-block;
        background-color: #1d4ed8; /* blue-700 */
        color: #e0e7ff; /* blue-100 */
        padding: 2px 8px;
        border-radius: 6px;
        font-size: 0.9em;
        font-weight: 500;
        -webkit-user-select: none; /* Safari */
        user-select: none;
      }
      details.popover-def summary::-webkit-details-marker {
        display: none; /* Hide the disclosure triangle */
      }
      details.popover-def:hover summary {
        background-color: #2563eb; /* blue-600 */
      }
      details.popover-def div {
        position: absolute;
        width: 300px;
        background-color: #1f2937; /* gray-800 */
        border: 1px solid #374151; /* gray-700 */
        border-radius: 8px;
        padding: 1rem;
        margin-top: 8px;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        z-index: 10;
      }

      /* Style for seminal paper info box */
      .paper-info {
        background-color: #1f2937; /* gray-800 */
        border-left: 4px solid #38bdf8; /* sky-400 */
        padding: 1rem;
        border-radius: 0 8px 8px 0;
        margin-top: 1rem;
        font-size: 0.9em;
      }
      .paper-info strong {
        color: #e0e0e0;
        display: block;
        margin-bottom: 0.25rem;
      }
    </style>
  </head>
  <body class="h-full flex">
    <!-- Sidebar Navigation -->
    <nav class="w-64 h-full bg-gray-800 p-4 space-y-2 fixed">
      <h2 class="text-2xl font-bold text-sky-400 mb-6">Complexity Explorer</h2>
      <a
        href="#"
        data-module="home"
        class="nav-link active block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >Home</a
      >
      <a
        href="#"
        data-module="visualizer"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >1. Time Complexity Visualizer</a
      >
      <a
        href="#"
        data-module="vertexCover"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >2. P vs. NP (Vertex Cover)</a
      >
      <a
        href="#"
        data-module="tsp"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >3. NP-Complete (TSP)</a
      >
      <a
        href="#"
        data-module="openProblems"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >4. Open Problems & The Future</a
      >
      <a
        href="#"
        data-module="reductions"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >5. Reductions (IS to VC)</a
      >
      <a
        href="#"
        data-module="pspace"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >6. PSPACE (TQBF)</a
      >
    </nav>

    <!-- Main Content Area -->
    <main class="flex-1 ml-64 h-full">
      <div id="module-content" class="module-content p-8 h-full">
        <!-- Dynamic content will be loaded here -->
      </div>
    </main>

    <script>
      // --- Core Application Logic ---

      // Global store for chart instances to destroy them
      let charts = {};

      // Module definitions
      const modules = {
        home: showHome,
        visualizer: showVisualizer,
        vertexCover: showVertexCover,
        tsp: showTSP,
        openProblems: showOpenProblems,
        reductions: showReductions,
        pspace: showPSPACE, // New module
      };

      // Simple router to show a module
      function showModule(moduleName) {
        // Destroy any existing charts before loading new content
        destroyCharts();

        const moduleFunction = modules[moduleName];
        if (moduleFunction) {
          moduleFunction();
          // Update active nav link
          document.querySelectorAll("nav a").forEach((a) => {
            a.classList.remove("active", "bg-gray-900", "text-sky-400");
            if (a.dataset.module === moduleName) {
              a.classList.add("active", "bg-gray-900", "text-sky-400");
            }
          });
          // After content is loaded, tell MathJax to re-scan the page
          if (window.MathJax) {
            MathJax.typesetPromise();
          }
        }
      }

      // Function to destroy Chart.js instances
      function destroyCharts() {
        Object.values(charts).forEach((chart) => chart.destroy());
        charts = {};
      }

      // --- Module 1: Home Screen ---
      function showHome() {
        const template = `
                <div class="text-center">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Welcome to the Complexity Explorer!</h2>
                    <p class="text-lg text-gray-300 mb-8">
                        An interactive tool for university students to get an intuitive feel for P, NP, and NP-Complete problems.
                    </p>
                </div>

                <div class="flex flex-wrap -mx-4 mt-8">
                    <!-- Column 1: Definitions -->
                    <div class="w-full lg:w-1/2 px-4 mb-4 md:mb-0">
                        <div class="bg-gray-800 p-6 rounded-lg h-full">
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">What is Complexity Theory?</h3>
                            <p class="text-gray-300 mb-4">
                                It's the study of how "hard" computational problems are. We classify problems by the *resources* (usually time or memory) required to solve them as the input size 'n' grows.
                            </p>
                            
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">The Big Classes: P vs. NP</h3>
                            <ul class="space-y-3">
                                <li>
                                    <span class="font-bold text-green-400">P (Polynomial Time):</span>
                                    <p class="text-sm text-gray-300">
                                        "Efficiently solvable" problems. $Time \\le O(n^k)$.
                                    </p>
                                </li>
                                <li>
                                    <span class="font-bold text-yellow-400">NP (Nondeterministic Polynomial Time):</span>
                                    <p class="text-sm text-gray-300">
                                        "Efficiently verifiable" problems. If given a potential solution, we can *check* if it's correct in polynomial time.
                                    </p>
                                </li>
                                <li>
                                    <span class="font-bold text-red-400">NP-Complete:</span>
                                    <p class="text-sm text-gray-300">
                                        The "hardest" problems in NP. $L \\le_p L_{npc}$ for all $L \\in \\text{NP}$.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </div>

                    <!-- Column 2: How to Use -->
                    <div class="w-full lg:w-1/2 px-4">
                        <div class="bg-gray-800 p-6 rounded-lg h-full">
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">How To Use This Tool</h3>
                            <ol class="list-decimal list-inside text-gray-300 space-y-4">
                                <li>
                                    <span class="font-bold text-cyan-400">Explore Growth (Module 1):</span>
                                    See the difference between $O(n^2)$ and $O(2^n)$ growth.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Feel the P vs. NP Gap (Module 2):</span>
                                    - **Verify (P):** Click 'Verify'. It's instant ($O(|V| \cdot |E|)$).
                                    <br>
                                    - **Solve (NP):** Click 'Find Optimal'. For a small graph (n=18), you will *feel* the exponential $O(2^n)$ delay.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Compare Brute-Force vs. Heuristic (Module 3):</span>
                                    - **Solve (NP):** Click 'Find Optimal Tour' with 9 cities. It takes seconds ($O(n!)$).
                                    <br>
                                    - **Approx. (P):** Click 'Find Heuristic Tour'. It's *instant* ($O(n^2)$).
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">See Reductions (Module 5):</span>
                                    Learn how **Independent Set** is a "mirror image" of **Vertex Cover**.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Explore PSPACE (Module 6):</span>
                                    See how the TQBF solver uses exponential *time* (recursive calls) but only polynomial *space* (recursion depth).
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Read the Research (Module 4):</span>
                                    See the actual papers that defined these "hard questions".
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>

                <!-- Foundational Research -->
                <div class="mt-8 pt-6 border-t border-gray-700">
                    <h3 class="text-2xl font-semibold text-cyan-400 mb-4">Learn More: Foundational Research</h3>
                    <div class="space-y-4 text-gray-300">
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Cook, S. A. (1971). "The complexity of theorem-proving procedures."</p>
                            <p class="text-sm mt-1">
                                **Summary:** This is the foundational paper that birthed the field of NP-Completeness. Cook proved that the **Satisfiability (SAT)** problem has a special property: *any* problem in NP can be "reduced" to it.
                            </p>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Karp, R. M. (1972). "Reducibility among combinatorial problems."</p>
                            <p class="text-sm mt-1">
                                **Summary:** Karp's paper took Cook's discovery and identified 21 other famous, seemingly unrelated problems (including Vertex Cover and TSP) that were also NP-Complete, establishing the vastness of the class.
                            </p>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Garey, M. R., & Johnson, D. S. (1979). "Computers and Intractability: A Guide to the Theory of NP-Completeness."</p>
                            <p class="text-sm mt-1">
                                **Summary:** This is the "bible" of NP-Completeness. It's not a research paper but a comprehensive textbook that standardized the theory and gave computer scientists a practical 'how-to' manual for dealing with intractable problems.
                            </p>
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
      }

      // --- Module 2: Time Complexity Visualizer ---
      function showVisualizer() {
        const template = `
                <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 1: Time Complexity Visualizer</h2>
                <p class="text-lg text-gray-300 mb-6">
                    A single chart can't show everything. Here are two charts to understand the two key scenarios.
                </p>
                
                <!-- Chart 1: Polynomial -->
                <h3 class="text-xl font-semibold text-gray-200 mb-3">Chart 1: The 'Fast' Algorithms (Polynomial Time)</h3>
                <p class="text-gray-300 mb-4">
                    This chart shows *only* the "fast" algorithms on a **linear scale**.
                    This lets you see the real, practical difference between $O(n)$, $O(n \\log n)$, and $O(n^2)$.
                </p>
                <div class="bg-gray-800 p-6 rounded-lg mb-8" style="height: 40vh;">
                    <canvas id="complexity-chart-p"></canvas>
                </div>

                <!-- Chart 2: P vs NP -->
                <h3 class="text-xl font-semibold text-gray-200 mb-3">Chart 2: The 'Explosion' (P vs. NP)</h3>
                <p class="text-gray-300 mb-4">
                    This chart compares $O(n^2)$ to the "slow" ones on a **logarithmic scale**.
                    Notice: 1. At small 'n', the lines are jumbled. 2. After $n=20$, $O(n!)$ disappears as it hits infinity.
                </p>
                <div class="bg-gray-800 p-6 rounded-lg" style="height: 40vh;">
                    <canvas id="complexity-chart-np"></canvas>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Chart.js configuration
        const chartOptions = (title, isLog) => ({
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              type: isLog ? "logarithmic" : "linear",
              beginAtZero: !isLog,
              grid: { color: "#4b5563" },
              ticks: {
                color: "#e0e0e0",
                callback: (value) =>
                  isLog ? Number(value).toExponential(0) : value,
              },
            },
            x: {
              grid: { color: "#4b5563" },
              ticks: { color: "#e0e0e0" },
            },
          },
          plugins: {
            legend: { labels: { color: "#e0e0e0" } },
            title: {
              display: true,
              text: title,
              color: "#e0e0e0",
              font: { size: 16 },
            },
          },
          interaction: { intersect: false, mode: "index" },
          animation: false,
        });

        // Data for Chart 1 (Polynomial)
        const nRangeP = Array.from({ length: 100 }, (_, i) => i + 1);
        const dataP = {
          labels: nRangeP,
          datasets: [
            {
              label: "O(n)",
              data: nRangeP.map((n) => n),
              borderColor: "#4ade80",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n log n)",
              data: nRangeP.map((n) => n * Math.log2(n)),
              borderColor: "#22d3ee",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n^2)",
              data: nRangeP.map((n) => n ** 2),
              borderColor: "#facc15",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
          ],
        };
        charts["chartP"] = new Chart(
          document.getElementById("complexity-chart-p").getContext("2d"),
          {
            type: "line",
            data: dataP,
            options: chartOptions("Polynomial Growth (n=1 to 100)", false),
          }
        );

        // Data for Chart 2 (Exponential)
        const nRangeNP = Array.from({ length: 25 }, (_, i) => i + 1);
        const factorial = (n) =>
          n > 20
            ? Infinity
            : Array.from({ length: n }, (_, i) => i + 1).reduce(
                (a, b) => a * b,
                1
              );
        const dataNP = {
          labels: nRangeNP,
          datasets: [
            {
              label: "O(n^2)",
              data: nRangeNP.map((n) => n ** 2),
              borderColor: "#facc15",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(2^n)",
              data: nRangeNP.map((n) => 2 ** n),
              borderColor: "#f87171",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n!)",
              data: nRangeNP.map((n) => factorial(n)),
              borderColor: "#f472b6",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
          ],
        };
        charts["chartNP"] = new Chart(
          document.getElementById("complexity-chart-np").getContext("2d"),
          {
            type: "line",
            data: dataNP,
            options: chartOptions("The P vs. NP 'Explosion' (n=1 to 25)", true),
          }
        );
      }

      // --- Helper: Tab switching logic ---
      function setupTabs(containerId) {
        const container = document.getElementById(containerId);
        const tabButtons = container.querySelectorAll(".tab-btn");
        const tabContents = container.querySelectorAll(".tab-content");

        tabButtons.forEach((button) => {
          button.addEventListener("click", () => {
            // Deactivate all
            tabButtons.forEach((btn) => btn.classList.remove("active"));
            tabContents.forEach((content) =>
              content.classList.remove("active")
            );

            // Activate clicked
            button.classList.add("active");
            document.getElementById(button.dataset.tab).classList.add("active");
          });
        });
      }

      // --- Helper: Graph Generators ---
      function generateRandomGraph(n, p) {
        let adjList = {};
        for (let i = 0; i < n; i++) adjList[i] = [];
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            if (Math.random() < p) {
              adjList[i].push(j);
              adjList[j].push(i);
            }
          }
        }
        return JSON.stringify(adjList, null, 2);
      }
      function generateCompleteGraph(n) {
        let adjList = {};
        for (let i = 0; i < n; i++) {
          adjList[i] = [];
          for (let j = 0; j < n; j++) {
            if (i !== j) adjList[i].push(j);
          }
        }
        return JSON.stringify(adjList, null, 2);
      }
      function generateRandomCities(n) {
        let cities = {};
        for (let i = 0; i < n; i++) {
          cities[String.fromCharCode(65 + i)] = {
            x: Math.floor(Math.random() * 101),
            y: Math.floor(Math.random() * 101),
          };
        }
        return JSON.stringify(cities, null, 2);
      }

      // --- Module 3: Vertex Cover Problem ---
      function showVertexCover() {
        const template = `
                <div id="vc-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 2: P vs. NP (Vertex Cover)</h2>
                    
                    <!-- Tab Navigation -->
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="vc-demo">Interactive Demo</button>
                        <button class="tab-btn" data-tab="vc-what-is">What is Vertex Cover?</button>
                        <button class="tab-btn" data-tab="vc-concepts">Key Concepts</button>
                    </div>

                    <!-- Tab Content: Interactive Demo -->
                    <div id="vc-demo" class="tab-content active">
                        <p class="text-lg text-gray-300 mb-6">
                            Experiment with the P vs. NP gap. **Verify** (fast) vs. **Solve** (slow) vs. **Approximate** (fast).
                        </p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- Left Column: Graph Input -->
                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="text-xl font-semibold mb-4">Graph Generators</h3>
                                <div class="flex space-x-2 mb-4">
                                    <button id="vc-gen-random" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">Random (n=10)</button>
                                    <button id="vc-gen-complete" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">Complete (K5)</button>
                                    <button id="vc-gen-large" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">Larger (n=15)</button>
                                </div>
                                
                                <label class="block text-sm font-medium text-gray-300">Graph (JSON Adjacency List)</label>
                                <textarea id="vc-graph" class="w-full h-32 bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700">{"A": ["B", "C"], "B": ["A", "C", "D"], "C": ["A", "B", "D"], "D": ["B", "C", "E"], "E": ["D"]}</textarea>
                                
                                <div id="vc-output" class="mt-4 p-4 bg-gray-900 rounded-lg text-gray-300 min-h-[50px]"></div>
                            </div>

                            <!-- Right Column: Actions -->
                            <div class="bg-gray-800 p-6 rounded-lg space-y-6">
                                <!-- Verify Action -->
                                <div>
                                    <h3 class="text-xl font-semibold mb-2 text-green-400">1. Verify a Solution (Fast - P)</h3>
                                    <label class="block text-sm font-medium text-gray-300">Proposed Cover (e.g., A,D)</label>
                                    <input id="vc-solution" type="text" class="w-full bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700" value="B,C,E">
                                    <button id="vc-verify-btn" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Verify (Polynomial Time)</button>
                                </div>

                                <!-- Find Solution Actions -->
                                <div>
                                    <h3 class="text-xl font-semibold mb-2 text-cyan-400">2. Find a Solution</h3>
                                    <p class="text-sm text-gray-400 mb-3">Compare the fast approximation vs. the slow optimal solver.</p>
                                    <div class="flex space-x-2">
                                        <button id="vc-approx-btn" class="w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Find 2-Approximation (Fast)</button>
                                        <button id="vc-solve-btn" class="w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Find Optimal Solution (Slow)</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab Content: What is VC? -->
                    <div id="vc-what-is" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">What is Vertex Cover?</h3>
                        <p class="mb-4">
                            A <span class="font-bold text-sky-400">Vertex Cover</span> is a subset of vertices $V' \subseteq V$ in a graph $G=(V, E)$ such that every edge $(u, v) \in E$
                            is "covered" (i.e., $\\{u, v\\} \cap V' \neq \emptyset$).
                        </p>
                        <h4 class="text-lg font-semibold mb-2">Formal Definition</h4>
                        <p class="mb-4 p-4 bg-gray-900 rounded-lg text-cyan-300">$$V' \subseteq V \\text{ s.t. } \\forall (u, v) \\in E, \\{u, v\\} \\cap V' \\neq \\emptyset$$</p>
                        
                        <h4 class="text-lg font-semibold mb-2">The NP-Complete Problem</h4>
                        <p class="mb-2">The *optimization* problem is "Find the *minimum* vertex cover."</p>
                        <p class="mb-2">The *decision* problem (NP-Complete) is **K-VERTEX-COVER**: "Given $G$ and $k$, does $G$ have a vertex cover of size $k$ or less?"</p>
                        <p class="mb-4 p-4 bg-gray-900 rounded-lg text-cyan-300">$$\\text{Does a } V' \\subseteq V \\text{ exist s.t. } |V'| \\le k \\text{ and } V' \\text{ is a VC for } G?$$</p>
                        
                        <h4 class="text-lg font-semibold mb-2">The P vs. NP vs. Approximation Tradeoff</h4>
                        <ul class="list-disc list-inside space-y-2">
                            <li><span class="font-bold text-green-400">Verifying is FAST (in P):</span> Check a solution in $O(|V| + |E|)$ time.</li>
                            <li><span class="font-bold text-blue-400">Approximating is FAST (in P):</span> Find a *good* solution in $O(|E|)$ time. The 2-approximation algorithm guarantees a cover no more than 2x the optimal size.</li>
                            <li><span class="font-bold text-red-400">Finding Optimal is SLOW (in NP):</span> Find the *best* solution in $O(2^{|V|} \cdot |E|)$ time (brute force).</li>
                        </ul>
                    </div>
                    
                    <!-- Tab Content: Key Concepts -->
                    <div id="vc-concepts" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-4">Key Concepts</h3>
                        <dl class="space-y-4">
                            <div><dt class="font-bold text-sky-400">Graph $G=(V, E)$</dt><dd>A set of **Vertices (V)** (nodes) and **Edges (E)** (links) that connect pairs of vertices.</dd></div>
                            <div><dt class="font-bold text-sky-400">Adjacency List</dt><dd>A representation of a graph where each vertex has a list of its neighbors (what the JSON represents).</dd></div>
                            <div><dt class="font-bold text-sky-400">Decision Problem vs. Optimization Problem</dt><dd>An **Optimization Problem** asks for the *best* solution (e.g., "Find the *smallest* cover"). A **Decision Problem** asks a "yes/no" question (e.g., "Is there a cover of size *k* or less?").</dd></div>
                            <div><dt class="font-bold text-sky-400">Approximation Algorithm</dt><dd>A fast (P-time) algorithm for an NP-hard optimization problem that guarantees a solution 'close' to the optimal one. For Vertex Cover, we have a **2-approximation**, meaning the cover it finds is at most $2 \times$ the size of the *true* smallest cover.</dd></div>
                        </dl>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Wire up event listeners
        document
          .getElementById("vc-verify-btn")
          .addEventListener("click", verifyVertexCover);
        document
          .getElementById("vc-approx-btn")
          .addEventListener("click", solveVertexCoverApprox);
        document
          .getElementById("vc-solve-btn")
          .addEventListener("click", solveVertexCoverOptimal);
        setupTabs("vc-container");
        const graphText = document.getElementById("vc-graph");
        document
          .getElementById("vc-gen-random")
          .addEventListener("click", () => {
            graphText.value = generateRandomGraph(10, 0.3);
          });
        document
          .getElementById("vc-gen-complete")
          .addEventListener("click", () => {
            graphText.value = generateCompleteGraph(5);
          });
        document
          .getElementById("vc-gen-large")
          .addEventListener("click", () => {
            graphText.value = generateRandomGraph(15, 0.2);
          });
      }

      // Helper function to get all unique edges from an adjacency list
      function getVCEdges(adjList) {
        const edges = new Set();
        for (const u in adjList) {
          for (const v of adjList[u]) {
            // Sort to avoid duplicates like A-B and B-A
            const uKey = isNaN(Number(u)) ? u : Number(u);
            const vKey = isNaN(Number(v)) ? v : Number(v);
            const edge = [uKey, vKey]
              .sort((a, b) => String(a).localeCompare(String(b)))
              .join("-");
            edges.add(edge);
          }
        }
        return edges;
      }

      // P-time algorithm to verify a VC solution
      function verifyVertexCover() {
        const output = document.getElementById("vc-output");
        try {
          const adjList = JSON.parse(document.getElementById("vc-graph").value);
          const solutionInput = document.getElementById("vc-solution").value;
          const solutionSet = new Set(
            solutionInput
              .split(",")
              .map((s) => s.trim())
              .filter(Boolean)
          );
          const edges = getVCEdges(adjList);
          let uncovered = [];
          let opCount = 0;
          for (const edge of edges) {
            opCount++;
            const [u, v] = edge.split("-");
            if (!solutionSet.has(u) && !solutionSet.has(v)) {
              uncovered.push(edge);
            }
          }
          if (uncovered.length === 0) {
            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>SUCCESS:</strong> This is a valid vertex cover.<br>(~${opCount} operations, P-time)`;
          } else {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>FAILED:</strong> This set does not cover:<br>${uncovered.join(
              ", "
            )}<br>(~${opCount} operations, P-time)`;
          }
        } catch (e) {
          output.className =
            "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
          output.textContent = `Error: ${e.message}`;
        }
      }

      // P-time 2-approximation algorithm
      function solveVertexCoverApprox() {
        const output = document.getElementById("vc-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent = "Finding 2-approximation (fast)...";

        setTimeout(() => {
          // Use timeout to allow UI to update
          try {
            const adjList = JSON.parse(
              document.getElementById("vc-graph").value
            );
            let edges = getVCEdges(adjList); // This is a Set
            const approxCover = new Set();
            let opCount = 0;
            const startTime = performance.now();

            while (edges.size > 0) {
              opCount++;
              // 1. Pick an arbitrary edge
              const [u, v] = edges.values().next().value.split("-");

              // 2. Add both nodes to cover
              approxCover.add(u);
              approxCover.add(v);

              // 3. Remove all covered edges
              const edgesToRemove = [];
              for (const edge of edges) {
                opCount++;
                const [e_u, e_v] = edge.split("-");
                if (approxCover.has(e_u) || approxCover.has(e_v)) {
                  edgesToRemove.push(edge);
                }
              }
              edgesToRemove.forEach((edge) => edges.delete(edge));
            }
            const endTime = performance.now();

            output.className =
              "mt-4 p-4 bg-blue-900 text-blue-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>APPROXIMATION FOUND:</strong> Cover: {${[
              ...approxCover,
            ].join(", ")}} (Size: ${
              approxCover.size
            }).<br>(~${opCount} operations, P-time)<br>Time: ${(
              endTime - startTime
            ).toFixed(2)} ms`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // NP-hard (brute-force) algorithm to find the optimal VC
      function solveVertexCoverOptimal() {
        const output = document.getElementById("vc-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent = "Solving (brute force)... This may take a moment.";

        setTimeout(() => {
          // Use timeout to allow UI to update
          try {
            const adjList = JSON.parse(
              document.getElementById("vc-graph").value
            );
            const vertices = Object.keys(adjList);
            const n = vertices.length;

            // Safety cap
            if (n > 20) {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.textContent =
                "Error: Graph is too large for client-side brute force (n > 20). This demonstrates exponential complexity!";
              return;
            }

            const edges = getVCEdges(adjList);
            let smallestCover = null;
            let opCount = 0;
            const startTime = performance.now();

            // Iterate through all 2^n subsets
            for (let i = 0; i < 1 << n; i++) {
              opCount++;
              const subset = new Set();
              for (let j = 0; j < n; j++) {
                if ((i >> j) & 1) {
                  subset.add(vertices[j]);
                }
              }

              // Check if this subset is a valid cover
              let isCover = true;
              for (const edge of edges) {
                opCount++;
                const [u, v] = edge.split("-");
                if (!subset.has(u) && !subset.has(v)) {
                  isCover = false;
                  break;
                }
              }

              // If it's a cover, see if it's the smallest
              if (isCover) {
                if (
                  smallestCover === null ||
                  subset.size < smallestCover.size
                ) {
                  smallestCover = subset;
                }
              }
            }
            const endTime = performance.now();

            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>OPTIMAL SOLVED:</strong> Cover is {${[
              ...smallestCover,
            ].join(", ")}} (Size: ${
              smallestCover.size
            }).<br>(~${opCount} operations, $O(2^n)$)<br>Time: ${(
              endTime - startTime
            ).toFixed(2)} ms`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // --- Module 4: Traveling Salesperson Problem (TSP) ---
      function showTSP() {
        const template = `
                <div id="tsp-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 3: NP-Complete (Traveling Salesperson)</h2>
                    
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="tsp-demo">Interactive Demo</button>
                        <button class="tab-btn" data-tab="tsp-what-is">What is TSP?</button>
                        <button class="tab-btn" data-tab="tsp-concepts">Key Concepts</button>
                    </div>

                    <!-- Tab Content: Demo -->
                    <div id="tsp-demo" class="tab-content active">
                        <p class="text-lg text-gray-300 mb-6">
                            Find the shortest route that visits each city once. This is $O(n!)$, which is even worse than $O(2^n)$!
                        </p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- Left Column: Demo -->
                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="text-xl font-semibold mb-4">City Generators</h3>
                                <div class="flex space-x-2 mb-4">
                                    <button id="tsp-gen-5" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">5 Random Cities</button>
                                    <button id="tsp-gen-8" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">8 Random Cities</button>
                                    <button id="tsp-gen-9" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">9 Random Cities</button>
                                </div>
                                <label class="block text-sm font-medium text-gray-300">Cities (JSON with x, y coords)</label>
                                <textarea id="tsp-cities" class="w-full h-32 bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700">{"A": {"x": 0, "y": 0}, "B": {"x": 10, "y": 5}, "C": {"x": 5, "y": 10}, "D": {"x": 15, "y": 0}}</textarea>
                                <div id="tsp-output" class="mt-4 p-4 bg-gray-900 rounded-lg text-gray-300 min-h-[50px]"></div>
                            </div>
                            <!-- Right Column: Actions -->
                            <div class="bg-gray-800 p-6 rounded-lg space-y-6">
                                <div>
                                    <h3 class="text-xl font-semibold mb-2 text-green-400">1. Verify a Tour Length (Fast - P)</h3>
                                    <label class="block text-sm font-medium text-gray-300">Proposed Tour (e.g., A,B,C,D,A)</label>
                                    <input id="tsp-tour" type="text" class="w-full bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700" value="A,C,B,D,A">
                                    <button id="tsp-verify-btn" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Verify (Polynomial Time)</button>
                                </div>
                                <div>
                                    <h3 class="text-xl font-semibold mb-2 text-cyan-400">2. Find a Solution</h3>
                                    <p class="text-sm text-gray-400 mb-3">Compare the fast heuristic vs. the *very* slow optimal solver.</p>
                                    <div class="flex space-x-2">
                                        <button id="tsp-heuristic-btn" class="w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Find Heuristic Tour (Fast)</button>
                                        <button id="tsp-solve-btn" class="w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Find Optimal Tour (Very Slow)</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab Content: What is TSP? -->
                    <div id="tsp-what-is" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">What is the Traveling Salesperson (TSP)?</h3>
                        <p class="mb-4">
                            Given a list of cities and the distances between them, what is the <span class="font-bold text-sky-400">shortest possible route</span> 
                            that visits each city exactly once and returns to the origin city?
                        </p>
                        <h4 class="text-lg font-semibold mb-2">Formal Definition</h4>
                        <p class="mb-2">Given a complete weighted graph $G = (V, E, w)$, find a **Hamiltonian cycle** (a tour that visits every vertex $v \\in V$ exactly once) with the minimum total weight.</p>
                        <p class="mb-4 p-4 bg-gray-900 rounded-lg text-cyan-300">Find $\\pi$ that minimizes:
                            $$w(v_{\\pi(n)}, v_{\\pi(1)}) + \\sum_{i=1}^{n-1} w(v_{\\pi(i)}, v_{\\pi(i+1)})$$
                        </p>
                        <h4 class="text-lg font-semibold mb-2">The P vs. NP vs. Heuristic Tradeoff</h4>
                        <ul class="list-disc list-inside space-y-2">
                            <li><span class="font-bold text-green-400">Verifying is FAST (in P):</span> Check a tour's length in $O(n)$ time.</li>
                            <li><span class="font-bold text-blue-400">Approximating is FAST (in P):</span> Find a *good* tour using a heuristic like "Nearest Neighbor" in $O(n^2)$ time. This gives *no guarantee* but is often good.</li>
                            <li><span class="font-bold text-red-400">Finding Optimal is SLOW (in NP):</span> Find the *best* tour in $O(n!)$ time (brute force).</li>
                        </ul>
                    </div>

                    <!-- Tab Content: Key Concepts -->
                    <div id="tsp-concepts" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-4">Key Concepts</h3>
                        <dl class="space-y-4">
                            <div><dt class="font-bold text-sky-400">Complete Graph</dt><dd>A graph where every pair of distinct vertices is connected by a unique edge.</dd></div>
                            <div><dt class="font-bold text-sky-400">Hamiltonian Cycle (or Tour)</dt><dd>A path in a graph that visits each vertex *exactly once* and returns to the starting vertex.</dd></div>
                            <div><dt class="font-bold text-sky-400">Factorial ($n!$)</dt><dd>The product of all positive integers less than or equal to $n$ ($n! = n \times ... \times 1$). This function grows *extremely* fast.</dd></div>
                            <div><dt class="font-bold text-sky-400">Heuristic Algorithm</dt><dd>A fast (P-time) algorithm or 'rule of thumb' for solving a problem. Unlike an approximation algorithm, a heuristic gives *no guarantee* on how close its answer is to the optimal one.</dd></div>
                        </dl>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Wire up event listeners
        document
          .getElementById("tsp-verify-btn")
          .addEventListener("click", verifyTSP);
        document
          .getElementById("tsp-heuristic-btn")
          .addEventListener("click", solveTSPHeuristic);
        document
          .getElementById("tsp-solve-btn")
          .addEventListener("click", solveTSPOptimal);
        setupTabs("tsp-container");
        const citiesText = document.getElementById("tsp-cities");
        document.getElementById("tsp-gen-5").addEventListener("click", () => {
          citiesText.value = generateRandomCities(5);
        });
        document.getElementById("tsp-gen-8").addEventListener("click", () => {
          citiesText.value = generateRandomCities(8);
        });
        document.getElementById("tsp-gen-9").addEventListener("click", () => {
          citiesText.value = generateRandomCities(9);
        });
      }

      // P-time algorithm to verify a TSP tour
      function getDist(cityA, cityB) {
        return Math.sqrt((cityA.x - cityB.x) ** 2 + (cityA.y - cityB.y) ** 2);
      }

      function verifyTSP() {
        const output = document.getElementById("tsp-output");
        try {
          const cities = JSON.parse(
            document.getElementById("tsp-cities").value
          );
          const tourInput = document.getElementById("tsp-tour").value;
          const tour = tourInput
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean);
          if (tour.length < 2)
            throw new Error("Tour must have at least 2 cities.");
          if (tour[0] !== tour[tour.length - 1])
            throw new Error("Tour must start and end at the same city.");
          let totalDist = 0;
          let opCount = 0;
          for (let i = 0; i < tour.length - 1; i++) {
            opCount++;
            const cityA = cities[tour[i]];
            const cityB = cities[tour[i + 1]];
            if (!cityA || !cityB)
              throw new Error(`Invalid city: ${tour[i]} or ${tour[i + 1]}`);
            totalDist += getDist(cityA, cityB);
          }
          output.className =
            "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
          output.innerHTML = `<strong>VERIFIED:</strong> Tour: ${tour.join(
            " -> "
          )}<br>Total Length: ${totalDist.toFixed(
            2
          )}<br>(~${opCount} operations, P-time)`;
        } catch (e) {
          output.className =
            "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
          output.textContent = `Error: ${e.message}`;
        }
      }

      // P-time Nearest Neighbor heuristic
      function solveTSPHeuristic() {
        const output = document.getElementById("tsp-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent = "Finding heuristic tour (Nearest Neighbor)...";
        setTimeout(() => {
          try {
            const cities = JSON.parse(
              document.getElementById("tsp-cities").value
            );
            const cityNames = Object.keys(cities);
            if (cityNames.length === 0) throw new Error("No cities provided.");
            const startTime = performance.now();
            let opCount = 0;
            const startCity = cityNames[0];
            const tour = [startCity];
            const unvisited = new Set(cityNames.slice(1));
            let totalDist = 0;
            let currentCityName = startCity;
            while (unvisited.size > 0) {
              opCount++;
              let nearestCity = null;
              let minDist = Infinity;
              const currentCityCoords = cities[currentCityName];
              for (const cityName of unvisited) {
                opCount++;
                const cityCoords = cities[cityName];
                const dist = getDist(currentCityCoords, cityCoords);
                if (dist < minDist) {
                  minDist = dist;
                  nearestCity = cityName;
                }
              }
              if (nearestCity) {
                totalDist += minDist;
                currentCityName = nearestCity;
                tour.push(currentCityName);
                unvisited.delete(currentCityName);
              } else {
                break;
              }
            }
            totalDist += getDist(cities[currentCityName], cities[startCity]);
            tour.push(startCity);
            const endTime = performance.now();
            output.className =
              "mt-4 p-4 bg-blue-900 text-blue-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>HEURISTIC FOUND:</strong> Tour: ${tour.join(
              " -> "
            )}<br>Length: ${totalDist.toFixed(
              2
            )}<br>(~${opCount} operations, $O(n^2)$)<br>Time: ${(
              endTime - startTime
            ).toFixed(2)} ms`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // NP-hard (brute-force) algorithm to find the optimal TSP tour
      function solveTSPOptimal() {
        const output = document.getElementById("tsp-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent =
          "Solving (brute force)... This will be very slow if n > 9.";
        setTimeout(() => {
          try {
            const cities = JSON.parse(
              document.getElementById("tsp-cities").value
            );
            const cityNames = Object.keys(cities);
            const n = cityNames.length;

            // Safety cap
            if (n > 9) {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.textContent = `Error: Too many cities (n=${n}). n > 9 will crash your browser with O(n!) complexity. This is the lesson!`;
              return;
            }

            const startCity = cityNames[0];
            const otherCities = cityNames.slice(1);
            let shortestDist = Infinity;
            let shortestTour = [];
            let opCount = 0;
            const startTime = performance.now();

            // Permutation generator
            function* permute(arr) {
              const n = arr.length;
              const c = new Array(n).fill(0);
              let a = [...arr];
              yield a;
              let i = 1;
              while (i < n) {
                if (c[i] < i) {
                  const k = i % 2 === 0 ? 0 : c[i];
                  [a[i], a[k]] = [a[k], a[i]];
                  c[i]++;
                  i = 1;
                  opCount++;
                  yield a;
                } else {
                  c[i] = 0;
                  i++;
                }
              }
            }

            // Check all (n-1)! permutations
            for (const perm of permute(otherCities)) {
              let currentDist = 0;
              const currentTour = [startCity, ...perm, startCity];
              for (let i = 0; i < currentTour.length - 1; i++) {
                const cityA = cities[currentTour[i]];
                const cityB = cities[currentTour[i + 1]];
                currentDist += getDist(cityA, cityB);
              }
              if (currentDist < shortestDist) {
                shortestDist = currentDist;
                shortestTour = currentTour;
              }
            }
            const endTime = performance.now();

            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>OPTIMAL SOLVED:</strong> Tour: ${shortestTour.join(
              " -> "
            )}<br>Length: ${shortestDist.toFixed(
              2
            )}<br>(~${opCount} permutations, $O(n!)$)<br>Time: ${(
              endTime - startTime
            ).toFixed(2)} ms`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // --- Module 5: Open Problems ---
      function showOpenProblems() {
        // This is the HTML template for the Open Problems module
        const template = `
                <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 4: Open Problems & The Future</h2>
                <p class="text-lg text-gray-300 mb-6">
                    Complexity theory is not a "solved" field. Click on the <span class="bg-blue-700 text-blue-100 px-2 py-1 rounded-md text-sm">Define</span> tags to learn more.
                </p>
                
                <div class="space-y-8">
                    <!-- 1. P vs NP -->
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">1. Is P = NP?</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Is every problem that can be *verified* quickly also *solvable* quickly?
                            <br>Formally: Does $\\text{P} = \\text{NP}$?
                        </p>
                        <div class="paper-info">
                            <strong>Stephen Cook's View (2000):</strong>
                            In his paper for the Clay Mathematics Institute (which established the $1M prize),
                            Stephen Cook wrote: *"My guess is that the answer is 'no'. ... a proof that P $\\neq$ NP
                            would be a milestone in mathematics ... a proof that P = NP would be even more
                            stunning."*
                            <br><br>
                            <strong>Seminal Paper:</strong> Cook, S. A. (2000). *The P vs. NP problem*. Clay Mathematics Institute.
                        </div>
                    </div>

                    <!-- 2. NP vs co-NP -->
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">2. Is NP = co-NP?</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** If a problem's "yes" answers are easy to verify, are its "no" answers also easy to verify?
                            <br>Formally: Does $\\text{NP} = \\text{co-NP}$?
                            <details class="popover-def">
                                <summary>Define: co-NP</summary>
                                <div><strong class="text-white">co-NP</strong> is the class of problems where "no" instances have a short, verifiable proof (a "counterexample"). Example: TAUTOLOGY (Is a formula *always* true? A "no" proof is a single assignment that makes it false).</div>
                            </details>
                        </p>
                        <div class="paper-info">
                            <strong>Seminal Paper:</strong> Pratt, V. (1975). *Every prime has a succinct certificate*.
                            <br><br>
                            This paper famously showed that PRIMES (checking if a number is prime)
                            is in both NP and co-NP, long before it was proven to be in P.
                        </div>
                    </div>

                    <!-- 3. ETH -->
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">3. The Exponential Time Hypothesis (ETH)</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Does the 3-SAT problem *really* require exponential time to solve?
                            <details class="popover-def">
                                <summary>Define: Sub-exponential Time</summary>
                                <div><strong class="text-white">Sub-exponential Time</strong> is faster than $O(2^{\\delta n})$ but slower than $O(n^k)$. ETH claims 3-SAT *cannot* be solved in this time.</div>
                            </details>
                        </p>
                        <div class="paper-info">
                            <strong>Seminal Paper:</strong> Impagliazzo, R., & Paturi, R. (1999). *On the complexity of k-SAT*.
                            <br><br>
                            This paper introduced the Exponential Time Hypothesis (ETH) and its variant,
                            the Strong Exponential Time Hypothesis (SETH).
                        </div>
                    </div>

                    <!-- 4. P vs PSPACE -->
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">4. Is P = PSPACE?</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Can every problem solvable with *polynomial memory* also be solved in *polynomial time*?
                            <details class="popover-def">
                                <summary>Define: PSPACE</summary>
                                <div><strong class="text-white">PSPACE</strong> is the set of problems solvable with a *polynomial* amount of memory, regardless of time. (e.g., solving chess).</div>
                            </details>
                        </p>
                        <div class="paper-info">
                            <strong>Seminal Paper:</strong> Savitch, W. J. (1970). *Relationships between nondeterministic and deterministic tape complexities*.
                            <br><br>
                            This paper contains **Savitch's Theorem**, which proves $\\text{NSPACE}(S(n)) \\subseteq \\text{DSPACE}(S(n)^2)$, and as a corollary that $\\text{PSPACE} = \\text{NPSPACE}$.
                        </div>
                    </div>

                    <!-- 5. BPP vs BQP -->
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">5. Is BPP = BQP? (Quantum)</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Can quantum computers solve problems that classical computers can't?
                            <details class="popover-def">
                                <summary>Define: BPP & BQP</summary>
                                <div><strong class="text-white">BPP:</strong> Problems solvable by a *classical* randomized algorithm in P-time. <br><br> <strong class="text-white">BQP:</strong> Problems solvable by a *quantum* algorithm in P-time.</div>
                            </details>
                        </p>
                        <div class="paper-info">
                            <strong>Seminal Papers:</strong>
                            <br>
                            1. Bernstein, E., & Vazirani, U. (1997). *Quantum complexity theory*. (Formally defined BQP).
                            <br>
                            2. Shor, P. W. (1994). *Algorithms for quantum computation... factoring*. (Showed Factoring is in BQP).
                        </div>
                    </div>
                    
                    <!-- 6. Factoring -->
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">6. The Status of Integer Factorization</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Can we factor a large number into its primes in polynomial time (on a classical computer)?
                            <details class="popover-def">
                                <summary>Define: NP-Intermediate</summary>
                                <div>Problems in NP that are neither in P nor NP-Complete. Their existence relies on P $\\neq$ NP.</div>
                            </details>
                            <br><br>
                            This is the problem that underpins RSA cryptography. It's believed to be in NP-Intermediate.
                        </p>
                        <div class="paper-info">
                            <strong>Seminal Paper:</strong> Shor, P. W. (1994). *Algorithms for quantum computation... factoring*.
                            <br><br>
                            This paper is so important it's cited twice, as it showed Factoring is *easy* for a quantum computer (in BQP), even though it's *hard* for classical computers.
                        </div>
                    </div>
                    
                    <!-- 7. Graph Isomorphism -->
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">7. The Status of Graph Isomorphism</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Can we efficiently determine if two graphs are identical (just with the nodes labeled differently)?
                            <details class="popover-def">
                                <summary>Define: Quasi-polynomial Time</summary>
                                <div>Faster than exponential ($O(2^n)$) but slower than polynomial ($O(n^k)$). Formally: $O(2^{(\\log n)^c})$.</div>
                            </details>
                            <br><br>
                            This is another famous "NP-Intermediate" candidate.
                        </p>
                        <div class="paper-info">
                            <strong>Seminal Paper:</strong> Babai, L. (2015). *Graph Isomorphism in Quasipolynomial Time*.
                            <br><br>
                            This paper presented the breakthrough quasi-polynomial algorithm,
                            strongly suggesting GI is *not* NP-Complete.
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Add click-to-close for other popovers
        document.querySelectorAll("details.popover-def").forEach((detail) => {
          detail.addEventListener("toggle", (e) => {
            if (e.target.open) {
              document
                .querySelectorAll("details.popover-def[open]")
                .forEach((openDetail) => {
                  if (openDetail !== e.target) openDetail.open = false;
                });
            }
          });
        });
      }

      // --- Module 6: Reductions ---
      function showReductions() {
        const template = `
                <div id="reductions-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 5: Reductions (Independent Set)</h2>
                    
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="reduction-what-is">What is a Reduction?</button>
                        <button class="tab-btn" data-tab="reduction-demo">Demo: IS $\\leftrightarrow$ VC</button>
                    </div>

                    <!-- Tab Content: What is a Reduction? -->
                    <div id="reduction-what-is" class="tab-content active bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">What is a Polynomial-Time Reduction?</h3>
                        <p class="mb-4">
                            A **reduction** is a way to solve one problem using an algorithm for *another* problem.
                            A polynomial-time reduction ($L \\le_p L'$) is a "fast" transformation that turns an instance
                            of problem $L$ into an instance of $L'$.
                        </p>
                        
                        <h4 class="text-lg font-semibold mb-2">Why do this?</h4>
                        <ol class="list-decimal list-inside space-y-2 mb-4">
                            <li><strong>To Solve Problems:</strong> If you have a "magic" (fast) solver for $L'$, you can now use it to solve $L$.</li>
                            <li><strong>To Prove Hardness:</strong> If we know $L$ is "hard" (e.g., NP-Complete), then $L'$ must *also* be "hard".</li>
                        </ol>
                        
                        <p class="mb-2">Formally, $L \\le_p L'$ if there's a P-time
                        function $f$ that converts any instance $x$ of $L$ into an instance $f(x)$ of $L'$ such that:</p>
                        <p class="p-4 bg-gray-900 rounded-lg text-cyan-300">
                            $$x \\in L \\iff f(x) \\in L'$$
                        </p>
                    </div>
                    
                    <!-- Tab Content: Demo -->
                    <div id="reduction-demo" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">Demo: Independent Set $\\leftrightarrow$ Vertex Cover</h3>
                        <p class="mb-4">
                            Let's show a simple reduction between two problems. This will prove they are
                            equally hard and that their optimization problems are linked.
                        </p>
                        
                        <h4 class="text-lg font-semibold mb-2">1. Define: Independent Set (IS)</h4>
                        <p class="mb-2">An **Independent Set** is a set of vertices $S \\subseteq V$ in a graph $G=(V,E)$
                        such that no two vertices in $S$ are connected by an edge.</p>
                        <p class="mb-4 p-4 bg-gray-900 rounded-lg text-cyan-300">
                            $$S \\subseteq V \\text{ s.t. } \\forall (u, v) \\in E, \\{u, v\\} \\not\\subseteq S$$
                        </p>
                        
                        <h4 class="text-lg font-semibold mb-2">2. The "Aha!" Moment: The Reduction</h4>
                        <p class="mb-4">The reduction is based on this beautiful theorem:</p>
                        
                        <div class="p-4 bg-green-900 text-green-200 rounded-lg mb-4">
                            <strong>Theorem:</strong> In any graph $G=(V,E)$, a set $S \\subseteq V$ is an **Independent Set**
                            if and only if its complement, $V \\setminus S$, is a **Vertex Cover**.
                        </div>
                        
                        <h4 class="text-lg font-semibold mb-2">Proof (IS $\\implies$ VC)</h4>
                        <ol class="list-decimal list-inside space-y-2 mb-4">
                            <li><strong>Assume:</strong> $S$ is an Independent Set.</li>
                            <li><strong>We must show:</strong> Its complement $C = V \\setminus S$ is a Vertex Cover.</li>
                            <li><strong>Proof:</strong> Take any edge $(u, v) \\in E$. Since $S$ is an IS, $u$ and $v$ *cannot* both be in $S$. At least one of them *must not* be in $S$.</li>
                            <li>Therefore, at least one of them *must* be in its complement, $C$. **$C$ is a Vertex Cover.**</li>
                        </ol>

                        <h4 class="text-lg font-semibold mb-2">Proof (VC $\\implies$ IS)</h4>
                        <ol class="list-decimal list-inside space-y-2 mb-4">
                            <li><strong>Assume:</strong> $C$ is a Vertex Cover.</li>
                            <li><strong>We must show:</strong> Its complement $S = V \\setminus C$ is an Independent Set.</li>
                            <li><strong>Proof:</strong> Take any two vertices $u, v \\in S$. We must show there is no edge between them.</li>
                            <li>Assume for contradiction that there *is* an edge $(u, v) \\in E$.</li>
                            <li>Because $C$ is a VC, it must cover this edge (at least one of $u$ or $v$ must be in $C$).</li>
                            <li>This is a contradiction! We *chose* $u$ and $v$ from $S$, so neither can be in $C$. **$S$ is an Independent Set.**</li>
                        </ol>
                        
                        <h4 class="text-lg font-semibold mb-2">Conclusion</h4>
                        <p>This proves $\\text{Independent Set} \\le_p \\text{Vertex Cover}$. It also means $|MaxIS| + |MinVC| = |V|$.
                        <br><br>
                        The $O(2^n)$ algorithm in **Module 2** that finds a *minimum vertex cover*
                        is, by this reduction, *also* an algorithm for finding a *maximum independent set*.
                        </ReadMe>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
        setupTabs("reductions-container");
      }

      // --- Module 7: PSPACE (TQBF) ---

      // This object will hold the stats for the TQBF solver
      let tqbfStats = { opCount: 0, maxDepth: 0 };

      // Helper to evaluate a CNF formula with given assignments
      function evaluateCNF_JS(formula, assignments) {
        tqbfStats.opCount++;
        for (const clause of formula) {
          let clauseSatisfied = false;
          for (const literal of clause) {
            const varName = literal.replace("-", "");
            const isNegated = literal.startsWith("-");

            if (!(varName in assignments)) continue;

            const assignedVal = assignments[varName];
            if ((isNegated && !assignedVal) || (!isNegated && assignedVal)) {
              clauseSatisfied = true;
              break;
            }
          }
          if (!clauseSatisfied) return false;
        }
        return true;
      }

      // The core recursive TQBF solver
      function solveRecursive_JS(
        quantifiers,
        formula,
        assignments,
        index,
        currentDepth
      ) {
        tqbfStats.opCount++;
        if (currentDepth > tqbfStats.maxDepth) {
          tqbfStats.maxDepth = currentDepth;
        }

        // Base case: All variables assigned
        if (index === quantifiers.length) {
          return evaluateCNF_JS(formula, assignments);
        }

        const varInfo = quantifiers[index];
        const varName = varInfo.var;
        const quantifier = varInfo.q;

        if (quantifier === "") {
          // 'For All' player: must be true for BOTH
          let assignmentsTrue = { ...assignments, [varName]: true };
          let resTrue = solveRecursive_JS(
            quantifiers,
            formula,
            assignmentsTrue,
            index + 1,
            currentDepth + 1
          );

          let assignmentsFalse = { ...assignments, [varName]: false };
          let resFalse = solveRecursive_JS(
            quantifiers,
            formula,
            assignmentsFalse,
            index + 1,
            currentDepth + 1
          );

          return resTrue && resFalse;
        } else {
          // quantifier === ''
          // 'Exists' player: must be true for AT LEAST ONE
          let assignmentsTrue = { ...assignments, [varName]: true };
          let resTrue = solveRecursive_JS(
            quantifiers,
            formula,
            assignmentsTrue,
            index + 1,
            currentDepth + 1
          );

          if (resTrue) return true; // Short-circuit

          let assignmentsFalse = { ...assignments, [varName]: false };
          let resFalse = solveRecursive_JS(
            quantifiers,
            formula,
            assignmentsFalse,
            index + 1,
            currentDepth + 1
          );

          return resFalse;
        }
      }

      // Main function to launch the TQBF solver
      function solveTQBF() {
        const output = document.getElementById("tqbf-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent =
          "Solving TQBF (Exponential Time, Polynomial Space)...";

        setTimeout(() => {
          // Timeout for UI update
          try {
            const data = JSON.parse(
              document.getElementById("tqbf-input").value
            );
            const { quantifiers, formula } = data;

            // Reset stats
            tqbfStats = { opCount: 0, maxDepth: 0 };

            const startTime = performance.now();
            const result = solveRecursive_JS(quantifiers, formula, {}, 0, 0);
            const endTime = performance.now();

            if (result) {
              output.className =
                "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
              output.innerHTML = `<strong>Result: TRUE</strong><br>Time: ${(
                endTime - startTime
              ).toFixed(2)} ms`;
            } else {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.innerHTML = `<strong>Result: FALSE</strong><br>Time: ${(
                endTime - startTime
              ).toFixed(2)} ms`;
            }

            // Add stats
            output.innerHTML += `<div class="mt-4 pt-4 border-t border-gray-600">
                        <p><strong>Total Recursive Calls (Time):</strong> ${tqbfStats.opCount}</p>
                        <p><strong>Max Recursion Depth (Space):</strong> ${tqbfStats.maxDepth}</p>
                    </div>`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      function showPSPACE() {
        const template = `
                <div id="pspace-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 6: PSPACE-Complete (TQBF)</h2>
                    
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="pspace-what-is">What is PSPACE?</button>
                        <button class="tab-btn" data-tab="pspace-demo">Interactive TQBF Demo</button>
                    </div>

                    <!-- Tab Content: What is PSPACE? -->
                    <div id="pspace-what-is" class="tab-content active bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">What is PSPACE?</h3>
                        <p class="mb-4">
                            **PSPACE** is the class of problems solvable by an algorithm that uses a **Polynomial amount of SPACE (memory)**,
                            regardless of how much *time* it takes.
                        </p>
                        <ul class="list-disc list-inside mb-4">
                            <li>We know $\\text{P} \\subseteq \\text{NP} \\subseteq \\text{PSPACE}$.</li>
                            <li>We strongly suspect $\\text{P} \\neq \\text{PSPACE}$ and $\\text{NP} \\neq \\text{PSPACE}$, but it's not proven.</li>
                        </ul>
                        
                        <h4 class="text-lg font-semibold mb-2">TQBF: The PSPACE-Complete Problem</h4>
                        <p class="mb-2">
                            The "hardest" problem in PSPACE is **TQBF (True Quantified Boolean Formulas)**.
                            It's like SAT, but with alternating "for all" ($\\forall$) and "there exists" ($\\exists$) quantifiers.
                        </p>
                        <p class="p-4 bg-gray-900 rounded-lg text-cyan-300">
                            $$\\forall x \\exists y \\forall z \\dots \\phi(x, y, z, \\dots)$$
                        </p>
                        
                        <h4 class="text-lg font-semibold my-2">Time vs. Space: The Key Lesson</h4>
                        <p class="mb-4">
                            We can solve TQBF with a simple recursive algorithm (like the one in the demo).
                            <br>
                            - **Time Complexity:** The algorithm branches for every variable, leading to $O(2^n)$ time. **(Exponential!)**
                            <br>
                            - **Space Complexity:** The algorithm only needs to store the current path down the recursion tree. The depth of this tree is $n$ (the number of variables). Therefore, it only uses $O(n)$ space. **(Polynomial!)**
                        </p>
                        <p class="font-bold">TQBF is the perfect example of a problem that is **easy on space** but **hard on time**.</p>
                        
                        <h4 class="text-lg font-semibold my-2">Two-Player Game Analogy</h4>
                        <p>
                            You can think of TQBF as a game:
                            <br>
                            - The **$\\exists$ player** wins if the formula is *True*.
                            <br>
                            - The **$\\forall$ player** wins if the formula is *False*.
                            <br>
                            The $\\exists$ player gets to pick values for $\\exists$ variables.
                            The $\\forall$ player gets to pick values for $\\forall$ variables.
                            <br>
                            The TQBF formula is *True* if the $\\exists$ player has a **winning strategy**, no matter what the $\\forall$ player does.
                        </p>
                    </div>
                    
                    <!-- Tab Content: Demo -->
                    <div id="pspace-demo" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">Interactive TQBF Solver</h3>
                        <p class="text-gray-300 mb-4">Note: The formula must be in CNF (an array of clauses).</p>
                        
                        <label class="block text-sm font-medium text-gray-300">TQBF JSON:</label>
                        <textarea id="tqbf-input" class="w-full h-48 bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700">
{
  "quantifiers": [
    {"var": "x", "q": ""},
    {"var": "y", "q": ""}
  ],
  "formula": [
    ["x", "y"],
    ["-x", "-y"]
  ]
}
                        </textarea>
                        
                        <button id="tqbf-solve-btn" class="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Solve TQBF (Exponential Time)</button>
                        
                        <div id="tqbf-output" class="mt-4 p-4 bg-gray-900 rounded-lg text-gray-300 min-h-[50px]">
                            Click "Solve TQBF" to see the result. The default formula $\\forall x \\exists y (x \lor y) \land (\\neg x \lor \\neg y)$ should evaluate to **True**.
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
        setupTabs("pspace-container");

        // Wire up TQBF solver button
        document
          .getElementById("tqbf-solve-btn")
          .addEventListener("click", solveTQBF);
      }

      // --- Initialization ---

      // Setup nav link listeners
      document.querySelectorAll("nav a").forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          const moduleName = e.currentTarget.dataset.module;
          showModule(moduleName);
        });
      });

      // Show home module on initial load
      window.onload = () => showModule("home");
    </script>
  </body>
</html>
