<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Complexity Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
          processEscapes: true,
        },
        startup: {
          ready: () => {
            MathJax.startup.defaultReady();
            MathJax.startup.promise.then(() => {
              console.log("MathJax all set!");
            });
          },
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>

    <style>
      /* Custom styles for a dark-mode app */
      body {
        font-family: "Inter", sans-serif;
        color: #e0e0e0;
      }
      .nav-link.active {
        background-color: #111827; /* gray-900 */
        color: #38bdf8; /* sky-400 */
      }
      /* Custom scrollbar for the main content area */
      .module-content {
        overflow-y: auto;
        max-height: 100vh;
      }
      .module-content::-webkit-scrollbar {
        width: 8px;
      }
      .module-content::-webkit-scrollbar-track {
        background: #1f2937; /* gray-800 */
      }
      .module-content::-webkit-scrollbar-thumb {
        background: #4b5563; /* gray-600 */
        border-radius: 4px;
      }
      .module-content::-webkit-scrollbar-thumb:hover {
        background: #6b7280; /* gray-500 */
      }

      /* Tab styles */
      .tab-btn {
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        background-color: #374151; /* gray-700 */
        color: #d1d5db; /* gray-300 */
        font-weight: 500;
        cursor: pointer;
      }
      .tab-btn.active {
        background-color: #38bdf8; /* sky-400 */
        color: #1e293b; /* gray-800 */
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }

      /* Popover/Details styles for Module 4 */
      details.popover-def {
        display: inline;
        cursor: pointer;
      }
      details.popover-def summary {
        display: inline-block;
        background-color: #1d4ed8; /* blue-700 */
        color: #e0e7ff; /* blue-100 */
        padding: 2px 8px;
        border-radius: 6px;
        font-size: 0.9em;
        font-weight: 500;
        -webkit-user-select: none; /* Safari */
        user-select: none;
      }
      details.popover-def summary::-webkit-details-marker {
        display: none; /* Hide the disclosure triangle */
      }
      details.popover-def:hover summary {
        background-color: #2563eb; /* blue-600 */
      }
      details.popover-def div {
        position: absolute;
        width: 300px;
        background-color: #1f2937; /* gray-800 */
        border: 1px solid #374151; /* gray-700 */
        border-radius: 8px;
        padding: 1rem;
        margin-top: 8px;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        z-index: 10;
      }

      /* Style for seminal paper info box */
      .paper-info {
        background-color: #1f2937; /* gray-800 */
        border-left: 4px solid #38bdf8; /* sky-400 */
        padding: 1rem;
        border-radius: 0 8px 8px 0;
        margin-top: 1rem;
        font-size: 0.9em;
      }
      .paper-info strong {
        color: #e0e0e0;
        display: block;
        margin-bottom: 0.25rem;
      }
    </style>
  </head>
  <body class="h-full flex">
    <nav class="w-64 h-full bg-gray-800 p-4 space-y-2 fixed">
      <h2 class="text-2xl font-bold text-sky-400 mb-6">Complexity Explorer</h2>
      <a
        href="#"
        data-module="home"
        class="nav-link active block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >Home</a
      >
      <a
        href="#"
        data-module="visualizer"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >1. Time Complexity Visualizer</a
      >
      <a
        href="#"
        data-module="vertexCover"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >2. P vs. NP (Vertex Cover)</a
      >
      <a
        href="#"
        data-module="tsp"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >3. NP-Complete (TSP)</a
      >
      <a
        href="#"
        data-module="openProblems"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >4. Open Problems & The Future</a
      >
      <a
        href="#"
        data-module="reductions"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >5. Reductions (IS to VC)</a
      >
      <a
        href="#"
        data-module="pspace"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >6. PSPACE (TQBF)</a
      >
      <a
        href="#"
        data-module="bpp"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >7. Randomized Algos (BPP)</a
      >
    </nav>

    <main class="flex-1 ml-64 h-full">
      <div id="module-content" class="module-content p-8 h-full"></div>
    </main>

    <script>
      // --- Core Application Logic ---

      // Global store for chart instances to destroy them
      let charts = {};

      // Module definitions
      const modules = {
        home: showHome,
        visualizer: showVisualizer,
        vertexCover: showVertexCover,
        tsp: showTSP,
        openProblems: showOpenProblems,
        reductions: showReductions,
        pspace: showPSPACE,
        bpp: showBPP, // <-- NEW MODULE
      };

      // Simple router to show a module
      function showModule(moduleName) {
        // Destroy any existing charts before loading new content
        destroyCharts();

        const moduleFunction = modules[moduleName];
        if (moduleFunction) {
          moduleFunction();
          // Update active nav link
          document.querySelectorAll("nav a").forEach((a) => {
            a.classList.remove("active", "bg-gray-900", "text-sky-400");
            if (a.dataset.module === moduleName) {
              a.classList.add("active", "bg-gray-900", "text-sky-400");
            }
          });
          // After content is loaded, tell MathJax to re-scan the page
          if (window.MathJax) {
            MathJax.typesetPromise();
          }
        }
      }

      // Function to destroy Chart.js instances
      function destroyCharts() {
        Object.values(charts).forEach((chart) => chart.destroy());
        charts = {};
      }

      // --- Module 1: Home Screen ---
      function showHome() {
        const template = `
                <div class="text-center">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Welcome to the Complexity Explorer!</h2>
                    <p class="text-lg text-gray-300 mb-8">
                        An interactive tool for university students to get an intuitive feel for P, NP, and NP-Complete problems.
                    </p>
                </div>

                <div class="flex flex-wrap -mx-4 mt-8">
                    <div class="w-full lg:w-1/2 px-4 mb-4 md:mb-0">
                        <div class="bg-gray-800 p-6 rounded-lg h-full">
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">What is Complexity Theory?</h3>
                            <p class="text-gray-300 mb-4">
                                It's the study of how "hard" computational problems are. We classify problems by the *resources* (usually time or memory) required to solve them as the input size 'n' grows.
                            </p>
                            
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">The Big Classes: P vs. NP</h3>
                            <ul class="space-y-3">
                                <li>
                                    <span class="font-bold text-green-400">P (Polynomial Time):</span>
                                    <p class="text-sm text-gray-300">
                                        "Efficiently solvable" problems. $Time \\le O(n^k)$.
                                    </p>
                                </li>
                                <li>
                                    <span class="font-bold text-yellow-400">NP (Nondeterministic Polynomial Time):</span>
                                    <p class="text-sm text-gray-300">
                                        "Efficiently verifiable" problems. If given a potential solution, we can *check* if it's correct in polynomial time.
                                    </p>
                                </li>
                                <li>
                                    <span class="font-bold text-red-400">NP-Complete:</span>
                                    <p class="text-sm text-gray-300">
                                        The "hardest" problems in NP. $L \\le_p L_{npc}$ for all $L \\in \\text{NP}$.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </div>

                    <div class="w-full lg:w-1/2 px-4">
                        <div class="bg-gray-800 p-6 rounded-lg h-full">
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">How To Use This Tool</h3>
                            <ol class="list-decimal list-inside text-gray-300 space-y-4">
                                <li>
                                    <span class="font-bold text-cyan-400">Explore Growth (Module 1):</span>
                                    See the difference between $O(n^2)$ and $O(2^n)$ growth.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Feel the P vs. NP Gap (Module 2):</span>
                                    - **Verify (P):** Click 'Verify'. It's instant ($O(|V| \cdot |E|)$).
                                    <br>
                                    - **Solve (NP):** Click 'Find Optimal'. For a small graph (n=18), you will *feel* the exponential $O(2^n)$ delay.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Compare Brute-Force vs. Heuristic (Module 3):</span>
                                    - **Solve (NP):** Click 'Find Optimal Tour' with 9 cities. It takes seconds ($O(n!)$).
                                    <br>
                                    - **Approx. (P):** Click 'Find Heuristic Tour'. It's *instant* ($O(n^2)$).
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">See Reductions (Module 5):</span>
                                    Learn how **Independent Set** is a "mirror image" of **Vertex Cover**.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Explore PSPACE (Module 6):</span>
                                    See how the TQBF solver uses exponential *time* (recursive calls) but only polynomial *space* (recursion depth).
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Explore BPP (Module 7):</span>
                                    See how a "slow" deterministic primality test ($O(\sqrt{n})$) is beaten by a "fast" randomized BPP algorithm.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Read the Research (Module 4):</span>
                                    See the actual papers that defined these "hard questions".
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>

                <div class="mt-8 pt-6 border-t border-gray-700">
                    <h3 class="text-2xl font-semibold text-cyan-400 mb-4">Learn More: Foundational Research</h3>
                    <div class="space-y-4 text-gray-300">
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Cook, S. A. (1971). "The complexity of theorem-proving procedures."</p>
                            <p class="text-sm mt-1">
                                **Summary:** This is the foundational paper that birthed the field of NP-Completeness. Cook proved that the **Satisfiability (SAT)** problem has a special property: *any* problem in NP can be "reduced" to it.
                            </p>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Karp, R. M. (1972). "Reducibility among combinatorial problems."</p>
                            <p class="text-sm mt-1">
                                **Summary:** Karp's paper took Cook's discovery and identified 21 other famous, seemingly unrelated problems (including Vertex Cover and TSP) that were also NP-Complete, establishing the vastness of the class.
                            </p>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Garey, M. R., & Johnson, D. S. (1979). "Computers and Intractability: A Guide to the Theory of NP-Completeness."</p>
                            <p class="text-sm mt-1">
                                **Summary:** This is the "bible" of NP-Completeness. It's not a research paper but a comprehensive textbook that standardized the theory and gave computer scientists a practical 'how-to' manual for dealing with intractable problems.
                            </p>
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
      }

      // --- Module 2: Time Complexity Visualizer ---
      function showVisualizer() {
        const template = `
                <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 1: Time Complexity Visualizer</h2>
                <p class="text-lg text-gray-300 mb-6">
                    A single chart can't show everything. Here are two charts to understand the two key scenarios.
                </p>
                
                <h3 class="text-xl font-semibold text-gray-200 mb-3">Chart 1: The 'Fast' Algorithms (Polynomial Time)</h3>
                <p class="text-gray-300 mb-4">
                    This chart shows *only* the "fast" algorithms on a **linear scale**.
                    This lets you see the real, practical difference between $O(n)$, $O(n \\log n)$, and $O(n^2)$.
                </p>
                <div class="bg-gray-800 p-6 rounded-lg mb-8" style="height: 40vh;">
                    <canvas id="complexity-chart-p"></canvas>
                </div>

                <h3 class="text-xl font-semibold text-gray-200 mb-3">Chart 2: The 'Explosion' (P vs. NP)</h3>
                <p class="text-gray-300 mb-4">
                    This chart compares $O(n^2)$ to the "slow" ones on a **logarithmic scale**.
                    Notice: 1. At small 'n', the lines are jumbled. 2. After $n=20$, $O(n!)$ disappears as it hits infinity.
                </p>
                <div class="bg-gray-800 p-6 rounded-lg" style="height: 40vh;">
                    <canvas id="complexity-chart-np"></canvas>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Chart.js configuration
        const chartOptions = (title, isLog) => ({
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              type: isLog ? "logarithmic" : "linear",
              beginAtZero: !isLog,
              grid: { color: "#4b5563" },
              ticks: {
                color: "#e0e0e0",
                callback: (value) =>
                  isLog ? Number(value).toExponential(0) : value,
              },
            },
            x: {
              grid: { color: "#4b5563" },
              ticks: { color: "#e0e0e0" },
            },
          },
          plugins: {
            legend: { labels: { color: "#e0e0e0" } },
            title: {
              display: true,
              text: title,
              color: "#e0e0e0",
              font: { size: 16 },
            },
          },
          interaction: { intersect: false, mode: "index" },
          animation: false,
        });

        // Data for Chart 1 (Polynomial)
        const nRangeP = Array.from({ length: 100 }, (_, i) => i + 1);
        const dataP = {
          labels: nRangeP,
          datasets: [
            {
              label: "O(n)",
              data: nRangeP.map((n) => n),
              borderColor: "#4ade80",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n log n)",
              data: nRangeP.map((n) => n * Math.log2(n)),
              borderColor: "#22d3ee",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n^2)",
              data: nRangeP.map((n) => n ** 2),
              borderColor: "#facc15",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
          ],
        };
        charts["chartP"] = new Chart(
          document.getElementById("complexity-chart-p").getContext("2d"),
          {
            type: "line",
            data: dataP,
            options: chartOptions("Polynomial Growth (n=1 to 100)", false),
          }
        );

        // Data for Chart 2 (Exponential)
        const nRangeNP = Array.from({ length: 25 }, (_, i) => i + 1);
        const factorial = (n) =>
          n > 20
            ? Infinity
            : Array.from({ length: n }, (_, i) => i + 1).reduce(
                (a, b) => a * b,
                1
              );
        const dataNP = {
          labels: nRangeNP,
          datasets: [
            {
              label: "O(n^2)",
              data: nRangeNP.map((n) => n ** 2),
              borderColor: "#facc15",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(2^n)",
              data: nRangeNP.map((n) => 2 ** n),
              borderColor: "#f87171",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n!)",
              data: nRangeNP.map((n) => factorial(n)),
              borderColor: "#f472b6",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
          ],
        };
        charts["chartNP"] = new Chart(
          document.getElementById("complexity-chart-np").getContext("2d"),
          {
            type: "line",
            data: dataNP,
            options: chartOptions("The P vs. NP 'Explosion' (n=1 to 25)", true),
          }
        );
      }

      // --- Helper: Tab switching logic ---
      function setupTabs(containerId) {
        const container = document.getElementById(containerId);
        const tabButtons = container.querySelectorAll(".tab-btn");
        const tabContents = container.querySelectorAll(".tab-content");

        tabButtons.forEach((button) => {
          button.addEventListener("click", () => {
            // Deactivate all
            tabButtons.forEach((btn) => btn.classList.remove("active"));
            tabContents.forEach((content) =>
              content.classList.remove("active")
            );

            // Activate clicked
            button.classList.add("active");
            document.getElementById(button.dataset.tab).classList.add("active");
          });
        });
      }

      // --- Helper: Graph Generators ---
      function generateRandomGraph(n, p) {
        let adjList = {};
        for (let i = 0; i < n; i++) adjList[i] = [];
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            if (Math.random() < p) {
              adjList[i].push(j);
              adjList[j].push(i);
            }
          }
        }
        return JSON.stringify(adjList, null, 2);
      }
      function generateCompleteGraph(n) {
        let adjList = {};
        for (let i = 0; i < n; i++) {
          adjList[i] = [];
          for (let j = 0; j < n; j++) {
            if (i !== j) adjList[i].push(j);
          }
        }
        return JSON.stringify(adjList, null, 2);
      }
      function generateRandomCities(n) {
        let cities = {};
        for (let i = 0; i < n; i++) {
          cities[String.fromCharCode(65 + i)] = {
            x: Math.floor(Math.random() * 101),
            y: Math.floor(Math.random() * 101),
          };
        }
        return JSON.stringify(cities, null, 2);
      }

      // --- Module 3: Vertex Cover Problem ---
      function showVertexCover() {
        const template = `
                <div id="vc-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 2: P vs. NP (Vertex Cover)</h2>
                    
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="vc-demo">Interactive Demo</button>
                        <button class="tab-btn" data-tab="vc-what-is">What is Vertex Cover?</button>
                    </div>

                    <div id="vc-what-is" class="tab-content">
                        <h3 class="text-2xl font-semibold mb-3">What is Vertex Cover?</h3>
                        <p class="text-gray-300 mb-4 text-lg">
                            A <span class="font-bold text-cyan-400">Vertex Cover</span> is a subset of vertices $V' \\subseteq V$ in a graph $G=(V, E)$
                            such that every edge $(u, v) \\in E$ is "covered" (i.e., at least one of $u$ or $v$ is in $V'$).
                        </p>
                        <p class="text-gray-400 mb-4 bg-gray-800 p-4 rounded-lg">
                           $V' \\subseteq V \\text{ s.t. } \\forall (u, v) \\in E, \\{u, v\\} \\cap V' \\neq \\emptyset$
                        </p>
                        
                        <h4 class="text-xl font-semibold mb-2">The NP-Complete Problem</h4>
                        <p class="text-gray-300 mb-4">
                            The *optimization* problem is "Find the *minimum* vertex cover."
                            <br>
                            The *decision* problem (NP-Complete) is **K-VERTEX-COVER**:
                            "Given $G$ and $k$, does $G$ have a vertex cover of size $k$ or less?"
                        </p>
                        
                        <h4 class="text-xl font-semibold mb-2">The P vs. NP vs. Approximation Tradeoff</h4>
                        <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li>
                                <span class="font-bold text-green-400">Verifying a Solution is FAST (in P):</span>
                                Given $V'$, check if it's a cover. ($O(|V| + |E|)$ time).
                            </li>
                            <li>
                                <span class="font-bold text-blue-400">Finding an Approx. Solution is FAST (in P):</span>
                                The 2-approximation algorithm in the demo runs in $O(|E|)$ time and is *guaranteed* to find a cover no more than 2x the optimal size.
                            </li>
                            <li>
                                <span class="font-bold text-red-400">Finding an Optimal Solution is SLOW (in NP):</span>
                                Finding the *smallest* cover is hard. The brute-force way is $O(2^|V| \cdot |E|)$ time.
                            </li>
                        </ul>
                    </div>
                    
                    <div id="vc-demo" class="tab-content active">
                        <p class="text-lg text-gray-300 mb-6">
                            Enter a graph as an adjacency list, or use a generator. Then, try to verify a solution (fast) or find the optimal one (slow).
                        </p>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="text-xl font-semibold mb-4">Graph Generators</h3>
                                <div class="flex space-x-2 mb-4">
                                    <button id="vc-gen-random" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-medium py-2 px-3 rounded-lg">Random (n=10)</button>
                                    <button id="vc-gen-k5" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-medium py-2 px-3 rounded-lg">Complete (K5)</button>
                                    <button id="vc-gen-large" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-medium py-2 px-3 rounded-lg">Larger (n=15)</button>
                                </div>

                                <label for="vc-graph" class="block text-sm font-medium text-gray-300 mb-2">Graph JSON (Adjacency List):</label>
                                <textarea id="vc-graph" rows="6" class="w-full p-2 bg-gray-900 text-gray-200 border border-gray-700 rounded-lg">{"A": ["B", "C"], "B": ["A", "C", "D"], "C": ["A", "B", "D"], "D": ["B", "C", "E"], "E": ["D"]}</textarea>
                            </div>

                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="text-xl font-semibold mb-4">1. Verify a Solution (P-Time)</h3>
                                <label for="vc-solution" class="block text-sm font-medium text-gray-300 mb-2">Proposed Solution (e.g., A,D):</label>
                                <div class="flex space-x-2">
                                    <input type="text" id="vc-solution" value="B,C,E" class="flex-1 p-2 bg-gray-900 text-gray-200 border border-gray-700 rounded-lg">
                                    <button id="vc-verify-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Verify</button>
                                </div>
                                
                                <hr class="my-6 border-gray-700">

                                <h3 class="text-xl font-semibold mb-4">2. Find a Solution</h3>
                                <div class="flex space-x-2">
                                    <button id="vc-approx-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">2-Approximation (Fast)</button>
                                    <button id="vc-solve-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Optimal (Slow)</button>
                                </div>
                            </div>
                        </div>

                        <div id="vc-output" class="mt-6 p-4 bg-gray-800 rounded-lg text-gray-300 min-h-[50px]">
                            Output will appear here.
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
        setupTabs("vc-container");

        // Wire up VC buttons
        const graphText = document.getElementById("vc-graph");
        document
          .getElementById("vc-gen-random")
          .addEventListener(
            "click",
            () => (graphText.value = generateRandomGraph(10, 0.3))
          );
        document
          .getElementById("vc-gen-k5")
          .addEventListener(
            "click",
            () => (graphText.value = generateCompleteGraph(5))
          );
        document
          .getElementById("vc-gen-large")
          .addEventListener(
            "click",
            () => (graphText.value = generateRandomGraph(15, 0.2))
          );

        document
          .getElementById("vc-verify-btn")
          .addEventListener("click", verifyVC);
        document
          .getElementById("vc-approx-btn")
          .addEventListener("click", solveVCApprox);
        document
          .getElementById("vc-solve-btn")
          .addEventListener("click", solveVCOptimal);
      }

      // --- VC Algorithm Implementations ---
      function getVCEdges(adjList) {
        const edges = new Set();
        for (const u in adjList) {
          for (const v of adjList[u]) {
            const edge = JSON.stringify([u, v].sort());
            edges.add(edge);
          }
        }
        return Array.from(edges).map((e) => JSON.parse(e));
      }

      function verifyVC() {
        const output = document.getElementById("vc-output");
        try {
          const adjList = JSON.parse(document.getElementById("vc-graph").value);
          const solutionText = document.getElementById("vc-solution").value;
          const solutionSet = new Set(
            solutionText.split(",").map((s) => s.trim())
          );
          const edges = getVCEdges(adjList);
          let uncovered = [];
          let opCount = 0;

          for (const [u, v] of edges) {
            opCount++;
            if (!solutionSet.has(u) && !solutionSet.has(v)) {
              uncovered.push(`${u}-${v}`);
            }
          }

          if (uncovered.length === 0) {
            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>VERIFICATION SUCCESSFUL:</strong> {${solutionText}} is a valid vertex cover.<br>(~${opCount} operations, $O(|E|)$)`;
          } else {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>VERIFICATION FAILED:</strong> The set does not cover these edges: ${uncovered.join(
              ", "
            )}.<br>(~${opCount} operations, $O(|E|)$)`;
          }
        } catch (e) {
          output.className =
            "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
          output.textContent = `Error: ${e.message}`;
        }
      }

      function solveVCApprox() {
        const output = document.getElementById("vc-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent = "Finding approximation...";

        setTimeout(() => {
          try {
            const adjList = JSON.parse(
              document.getElementById("vc-graph").value
            );
            const startTime = performance.now();
            let opCount = 0;
            let edges = new Set(getVCEdges(adjList).map(JSON.stringify));
            let approxCover = new Set();

            while (edges.size > 0) {
              opCount++;
              const [u, v] = JSON.parse(edges.values().next().value);
              edges.delete(JSON.stringify([u, v]));
              approxCover.add(u);
              approxCover.add(v);

              let edgesToRemove = [];
              for (const edgeStr of edges) {
                opCount++;
                const [e1, e2] = JSON.parse(edgeStr);
                if (e1 === u || e1 === v || e2 === u || e2 === v) {
                  edgesToRemove.push(edgeStr);
                }
              }
              edgesToRemove.forEach((edgeStr) => edges.delete(edgeStr));
            }

            const endTime = performance.now();
            output.className =
              "mt-4 p-4 bg-blue-900 text-blue-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>APPROXIMATION FOUND:</strong> Cover is {${[
              ...approxCover,
            ].join(", ")}} (Size: ${
              approxCover.size
            }).<br>(~${opCount} operations, $O(|E|)$)<br>Time: ${(
              endTime - startTime
            ).toFixed(2)} ms`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      function solveVCOptimal() {
        const output = document.getElementById("vc-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent = "Solving (Brute Force)... This may take a moment.";

        setTimeout(() => {
          try {
            const adjList = JSON.parse(
              document.getElementById("vc-graph").value
            );
            const vertices = Object.keys(adjList);
            const edges = getVCEdges(adjList);
            const n = vertices.length;

            if (n > 18) {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.textContent =
                "Error: Graph is too large for client-side brute-force (n > 18). This demonstrates exponential complexity!";
              return;
            }

            const startTime = performance.now();
            let opCount = 0;
            let smallestCover = null;

            for (let i = 0; i < 1 << n; i++) {
              opCount++;
              let subset = new Set();
              for (let j = 0; j < n; j++) {
                if ((i >> j) & 1) {
                  subset.add(vertices[j]);
                }
              }

              let isCover = true;
              for (const [u, v] of edges) {
                opCount++;
                if (!subset.has(u) && !subset.has(v)) {
                  isCover = false;
                  break;
                }
              }

              if (isCover) {
                if (
                  smallestCover === null ||
                  subset.size < smallestCover.size
                ) {
                  smallestCover = subset;
                }
              }
            }
            const endTime = performance.now();
            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>OPTIMAL SOLVED:</strong> Cover is {${[
              ...smallestCover,
            ].join(", ")}} (Size: ${
              smallestCover.size
            }).<br>(~${opCount} operations, $O(2^n)$)<br>Time: ${(
              endTime - startTime
            ).toFixed(2)} ms`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // --- Module 4: Traveling Salesperson Problem (TSP) ---
      function showTSP() {
        const template = `
                <div id="tsp-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 3: NP-Complete (Traveling Salesperson)</h2>
                    
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="tsp-demo">Interactive Demo</button>
                        <button class="tab-btn" data-tab="tsp-what-is">What is TSP?</button>
                    </div>

                    <div id="tsp-what-is" class="tab-content">
                        <h3 class="text-2xl font-semibold mb-3">What is the Traveling Salesperson (TSP)?</h3>
                        <p class="text-gray-300 mb-4 text-lg">
                            Given a list of cities and the distances between them, what is the <span class="font-bold text-cyan-400">shortest possible route</span> 
                            that visits each city exactly once and returns to the origin city?
                        </p>
                        <p class="text-gray-400 mb-4 bg-gray-800 p-4 rounded-lg">
                           Formally: Given a complete weighted graph $G = (V, E, w)$, find a **Hamiltonian cycle**
                           with the minimum total weight.
                        </p>
                        
                        <h4 class="text-xl font-semibold mb-2">The NP-Complete Problem</h4>
                        <p class="text-gray-300 mb-4">
                            The *optimization* problem is "Find the *shortest* tour."
                            <br>
                            The *decision* problem (NP-Complete) is **K-TSP**:
                            "Given $G$, $w$, and $k$, does $G$ have a tour with a total weight less than or equal to $k$?"
                        </p>
                        
                        <h4 class="text-xl font-semibold mb-2">The P vs. NP vs. Heuristic Tradeoff</h4>
                        <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li>
                                <span class="font-bold text-green-400">Verifying a Solution is FAST (in P):</span>
                                Given a path $\\pi$, add up the distances ($O(n)$ time).
                            </li>
                            <li>
                                <span class="font-bold text-blue-400">Finding a Heuristic Solution is FAST (in P):</span>
                                The **Nearest Neighbor** heuristic (always go to the closest unvisited city) is $O(n^2)$ time. It provides a "good enough" solution, but no guarantee on its quality.
                            </li>
                            <li>
                                <span class="font-bold text-red-400">Finding an Optimal Solution is SLOW (in NP):</span>
                                Finding the *shortest* tour is hard. The brute-force way is to check all $(n-1)!$ possible tours ($O(n!)$ time).
                            </li>
                        </ul>
                    </div>
                    
                    <div id="tsp-demo" class="tab-content active">
                        <p class="text-lg text-gray-300 mb-6">
                            Find the shortest route. This is $O(n!)$, which is even worse than $O(2^n)$!
                        </p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="text-xl font-semibold mb-4">City Generators</h3>
                                <div class="flex space-x-2 mb-4">
                                    <button id="tsp-gen-5" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-medium py-2 px-3 rounded-lg">5 Random Cities</button>
                                    <button id="tsp-gen-8" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-medium py-2 px-3 rounded-lg">8 Random Cities</button>
                                    <button id="tsp-gen-9" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-medium py-2 px-3 rounded-lg">9 Random Cities</button>
                                </div>

                                <label for="tsp-cities" class="block text-sm font-medium text-gray-300 mb-2">Cities JSON:</label>
                                <textarea id="tsp-cities" rows="6" class="w-full p-2 bg-gray-900 text-gray-200 border border-gray-700 rounded-lg">{"A": {"x": 0, "y": 0}, "B": {"x": 10, "y": 5}, "C": {"x": 5, "y": 10}, "D": {"x": 15, "y": 0}}</textarea>
                            </div>

                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="text-xl font-semibold mb-4">1. Verify a Tour (P-Time)</h3>
                                <label for="tsp-tour" class="block text-sm font-medium text-gray-300 mb-2">Proposed Tour (e.g., A,C,B,D,A):</label>
                                <div class="flex space-x-2">
                                    <input type="text" id="tsp-tour" value="A,C,B,D,A" class="flex-1 p-2 bg-gray-900 text-gray-200 border border-gray-700 rounded-lg">
                                    <button id="tsp-verify-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Verify</button>
                                </div>
                                
                                <hr class="my-6 border-gray-700">

                                <h3 class="text-xl font-semibold mb-4">2. Find a Solution</h3>
                                <div class="flex space-x-2">
                                    <button id="tsp-heuristic-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Heuristic (Fast)</button>
                                    <button id="tsp-solve-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Optimal (Slow)</button>
                                </div>
                            </div>
                        </div>

                        <div id="tsp-output" class="mt-6 p-4 bg-gray-800 rounded-lg text-gray-300 min-h-[50px]">
                            Output will appear here.
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
        setupTabs("tsp-container");

        // Wire up TSP buttons
        const citiesText = document.getElementById("tsp-cities");
        document
          .getElementById("tsp-gen-5")
          .addEventListener(
            "click",
            () => (citiesText.value = generateRandomCities(5))
          );
        document
          .getElementById("tsp-gen-8")
          .addEventListener(
            "click",
            () => (citiesText.value = generateRandomCities(8))
          );
        document
          .getElementById("tsp-gen-9")
          .addEventListener(
            "click",
            () => (citiesText.value = generateRandomCities(9))
          );

        document
          .getElementById("tsp-verify-btn")
          .addEventListener("click", verifyTSP);
        document
          .getElementById("tsp-heuristic-btn")
          .addEventListener("click", solveTSPHeuristic);
        document
          .getElementById("tsp-solve-btn")
          .addEventListener("click", solveTSPOptimal);
      }

      // --- TSP Algorithm Implementations ---
      function getDist(cityA, cityB) {
        return Math.sqrt((cityA.x - cityB.x) ** 2 + (cityA.y - cityB.y) ** 2);
      }

      function verifyTSP() {
        const output = document.getElementById("tsp-output");
        try {
          const cities = JSON.parse(
            document.getElementById("tsp-cities").value
          );
          const tourInput = document.getElementById("tsp-tour").value;
          const tour = tourInput
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean);
          if (tour.length < 2)
            throw new Error("Tour must have at least 2 cities.");
          if (tour[0] !== tour[tour.length - 1])
            throw new Error("Tour must start and end at the same city.");

          let totalDist = 0;
          let opCount = 0;
          for (let i = 0; i < tour.length - 1; i++) {
            opCount++;
            const cityA = cities[tour[i]];
            const cityB = cities[tour[i + 1]];
            if (!cityA || !cityB)
              throw new Error(`Invalid city: ${tour[i]} or ${tour[i + 1]}`);
            totalDist += getDist(cityA, cityB);
          }
          output.className =
            "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
          output.innerHTML = `<strong>VERIFICATION COMPLETE:</strong> Tour ${tour.join(
            " &rarr; "
          )} has length ${totalDist.toFixed(
            2
          )}.<br>(~${opCount} operations, $O(n)$)`;
        } catch (e) {
          output.className =
            "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
          output.textContent = `Error: ${e.message}`;
        }
      }

      function solveTSPHeuristic() {
        const output = document.getElementById("tsp-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent = "Finding heuristic tour (Nearest Neighbor)...";

        setTimeout(() => {
          try {
            const cities = JSON.parse(
              document.getElementById("tsp-cities").value
            );
            const cityNames = Object.keys(cities);
            if (cityNames.length === 0) throw new Error("No cities to visit.");

            const startTime = performance.now();
            let opCount = 0;
            const startCity = cityNames[0];
            let tour = [startCity];
            let unvisited = new Set(cityNames.slice(1));
            let totalDist = 0;
            let currentCityName = startCity;

            while (unvisited.size > 0) {
              opCount++;
              let nearestCity = null;
              let minDist = Infinity;
              const currentCityCoords = cities[currentCityName];

              for (const cityName of unvisited) {
                opCount++;
                const cityCoords = cities[cityName];
                const dist = getDist(currentCityCoords, cityCoords);
                if (dist < minDist) {
                  minDist = dist;
                  nearestCity = cityName;
                }
              }
              totalDist += minDist;
              currentCityName = nearestCity;
              tour.push(currentCityName);
              unvisited.delete(currentCityName);
            }
            totalDist += getDist(cities[currentCityName], cities[startCity]);
            tour.push(startCity);
            const endTime = performance.now();

            output.className =
              "mt-4 p-4 bg-blue-900 text-blue-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>HEURISTIC FOUND:</strong> Tour: ${tour.join(
              " &rarr; "
            )}<br>Length: ${totalDist.toFixed(
              2
            )}<br>(~${opCount} operations, $O(n^2)$)<br>Time: ${(
              endTime - startTime
            ).toFixed(2)} ms`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // Need a permutation helper for TSP
      function* getPermutations(arr) {
        if (arr.length === 0) {
          yield [];
          return;
        }
        const first = arr[0];
        const rest = arr.slice(1);
        for (const perm of getPermutations(rest)) {
          for (let i = 0; i <= perm.length; i++) {
            yield [...perm.slice(0, i), first, ...perm.slice(i)];
          }
        }
      }
      // A more efficient permutation generator (Heap's)
      function* permute(arr) {
        const c = new Array(arr.length).fill(0);
        yield arr.slice();
        let i = 1;
        while (i < arr.length) {
          if (c[i] < i) {
            const k = i % 2 === 0 ? 0 : c[i];
            [arr[i], arr[k]] = [arr[k], arr[i]]; // swap
            c[i]++;
            i = 1;
            yield arr.slice();
          } else {
            c[i] = 0;
            i++;
          }
        }
      }

      function solveTSPOptimal() {
        const output = document.getElementById("tsp-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent =
          "Solving (Brute Force)... This will be very slow if n > 9.";

        setTimeout(() => {
          try {
            const cities = JSON.parse(
              document.getElementById("tsp-cities").value
            );
            const cityNames = Object.keys(cities);
            const n = cityNames.length;
            if (n > 9) {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.textContent =
                "Error: Too many cities (n > 9). n > 9 will crash your browser with O(n!) complexity. This is the lesson!";
              return;
            }

            const startCity = cityNames[0];
            const otherCities = cityNames.slice(1);
            let shortestDist = Infinity;
            let shortestTour = [];
            let opCount = 0;
            const startTime = performance.now();

            for (const perm of permute(otherCities)) {
              opCount++;
              let currentDist = 0;
              let currentTour = [startCity, ...perm, startCity];
              for (let i = 0; i < currentTour.length - 1; i++) {
                opCount++;
                const cityA = cities[currentTour[i]];
                const cityB = cities[currentTour[i + 1]];
                currentDist += getDist(cityA, cityB);
              }
              if (currentDist < shortestDist) {
                shortestDist = currentDist;
                shortestTour = currentTour;
              }
            }
            const endTime = performance.now();
            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>OPTIMAL SOLVED:</strong> Tour: ${shortestTour.join(
              " &rarr; "
            )}<br>Length: ${shortestDist.toFixed(
              2
            )}<br>(~${opCount} operations, $O(n!)$)<br>Time: ${(
              endTime - startTime
            ).toFixed(2)} ms`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // --- Module 5: Open Problems ---
      function showOpenProblems() {
        const template = `
                <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 4: Open Problems & The Future</h2>
                <p class="text-lg text-gray-300 mb-6">
                    Complexity theory is not a "solved" field. It's an active area of research with
                    some of the deepest, most difficult questions in all of computer science.
                </p>

                <div class="space-y-8">
                    <div>
                        <h3 class="text-2xl font-semibold mb-2">1. Is P = NP?</h3>
                        <p class="text-gray-300">
                            **The Question:** Is every problem that can be *verified* quickly also *solvable* quickly?
                            <br>
                            **Formally:** Does $\\text{P} = \\text{NP}$?
                            <br><br>
                            This is the most famous problem in computer science. The consensus is that **P $\\neq$ NP**, but proving it remains one of the hardest challenges ever conceived.
                        </p>
                        <div class="paper-info">
                            <strong>Stephen Cook's View (2000):</strong>
                            <br>
                            In his paper for the Clay Mathematics Institute (which established the $1M prize),
                            Stephen Cook wrote: *"My guess is that the answer is 'no'. ... a proof that P  NP
                            would be a milestone in mathematics ... a proof that P = NP would be even more
                            stunning."*
                            <br><br>
                            <strong>Seminal Paper:</strong> Cook, S. A. (2000). *The P vs. NP problem*. Clay Mathematics Institute.
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-2xl font-semibold mb-2">2. Is NP = co-NP?</h3>
                        <p class="text-gray-300">
                            **The Question:** If a problem's "yes" answers are easy to verify, are its "no" answers also easy to verify?
                            <br>
                            **Formally:** Does $\\text{NP} = \\text{co-NP}$?
                            
                            <details class="popover-def">
                                <summary>Define: co-NP</summary>
                                <div>
                                    **co-NP** is the class of problems where "no" instances have a short, verifiable proof (a "counterexample").
                                    <br><br>
                                    **Example: TAUTOLOGY.**
                                    - **Problem:** Is this Boolean formula *always* true?
                                    - **"No" Proof:** If the answer is "no," you can provide a counterexample: an assignment of variables that makes the formula *false*.
                                    - We can verify this counterexample quickly, so TAUTOLOGY is in co-NP.
                                </div>
                            </details>
                            
                            <br><br>
                            If NP $\\neq$ co-NP (which is widely believed), it would imply that proving something is *always* true is fundamentally harder than proving it's *sometimes* true (SAT). It would also prove P $\\neq$ NP.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold mb-2">3. The Exponential Time Hypothesis (ETH)</h3>
                        <p class="text-gray-300">
                            **The Question:** Does the 3-SAT problem *really* require exponential time to solve?
                            <br>
                            **Formally:** The ETH conjectures that there is no algorithm for 3-SAT that runs in *sub-exponential time*.
                            
                            <details class="popover-def">
                                <summary>Define: Sub-exponential Time</summary>
                                <div>
                                    An algorithm that is faster than $O(2^{\\delta n})$ for all $\\delta > 0$, but still slower than polynomial time.
                                    <br><br>
                                    - **Exponential:** $O(2^n)$
                                    - **Sub-exponential:** $O(2^{n^{0.5}})$
                                    - **Polynomial:** $O(n^2)$
                                </div>
                            </details>
                        </p>
                        <div class="paper-info">
                            <strong>Seminal Paper:</strong> Impagliazzo, R., & Paturi, R. (1999). *On the complexity of k-SAT*.
                            <br><br>
                            This paper introduced the Exponential Time Hypothesis (ETH) and its variant,
                            the Strong Exponential Time Hypothesis (SETH), which are now central assumptions
                            in fine-grained complexity.
                        </div>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold mb-2">4. Is P = PSPACE?</h3>
                        <p class="text-gray-300">
                            **The Question:** Can every problem that is solvable using a *polynomial amount of memory* also be solved using a *polynomial amount of time*?
                            <br>
                            **Formally:** Does $\\text{P} = \\text{PSPACE}$?

                            <details class="popover-def">
                                <summary>Define: PSPACE</summary>
                                <div>
                                    **PSPACE** is the set of all problems that can be solved by an algorithm using a *polynomial* amount of memory (space), regardless of how much *time* it takes.
                                    <br><br>
                                    We know $\\text{P} \\subseteq \\text{NP} \\subseteq \\text{PSPACE}$.
                                </div>
                            </details>
                            <br><br>
                            We strongly believe $\\text{P} \\neq \\text{PSPACE}$, meaning some problems are *fundamentally* space-efficient but time-inefficient.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold mb-2">5. Is BPP = BQP? (Quantum Computing)</h3>
                        <p class="text-gray-300">
                            **The Question:** Can quantum computers solve problems that classical computers can't?
                            <br>
                            **Formally:** Does $\\text{BPP} = \\text{BQP}$?

                            <details class="popover-def">
                                <summary>Define: BPP & BQP</summary>
                                <div>
                                    - **BPP (Bounded-error Probabilistic Polynomial time):**
                                    Problems a *classical* computer can solve efficiently with randomness.
                                    <br><br>
                                    - **BQP (Bounded-error Quantum Polynomial time):**
                                    Problems a *quantum* computer can solve efficiently.
                                </div>
                            </details>
                            <br><br>
                            We know $\\text{BPP} \\subseteq \\text{BQP}$. The big question is whether the inclusion is strict. Shor's algorithm for **integer factorization** is in BQP but is *not* believed to be in BPP.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold mb-2">6. The Status of Integer Factorization</h3>
                        <p class="text-gray-300">
                            **The Question:** Can we factor a large number into its primes in polynomial time (on a classical computer)?
                            <br><br>
                            This is the problem that underpins almost all modern cryptography (like RSA). It's in a special class called **NP-Intermediate**.

                            <details class="popover-def">
                                <summary>Define: NP-Intermediate</summary>
                                <div>
                                    Problems that are in **NP**, but are *not* in **P** and are also *not* **NP-Complete**.
                                    <br><br>
                                    They are "hard," but not the "hardest" problems in NP.
                                </div>
                            </details>
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold mb-2">7. The Status of Graph Isomorphism</h3>
                        <p class="text-gray-300">
                            **The Question:** Can we efficiently determine if two graphs are identical (just with the nodes labeled differently)?
                            <br><br>
                            <details class="popover-def">
                                <summary>Define: Quasi-polynomial Time</summary>
                                <div>
                                    An algorithm that is *almost* polynomial.
                                    - **Polynomial:** $O(n^k)$
                                    - **Quasi-polynomial:** $O(2^{(\\log n)^c})$
                                    <br><br>
                                    This is *much* faster than exponential ($O(2^n)$) but slightly slower than any true polynomial.
                                </div>
                            </details>
                            <br><br>
                            This is another famous "NP-Intermediate" candidate. In 2015, a "quasi-polynomial" time algorithm was announced.
                        </p>
                        <div class="paper-info">
                            <strong>Seminal Paper:</strong> Babai, L. (2015). *Graph Isomorphism in Quasipolynomial Time*.
                            <br><br>
                            This paper presented the breakthrough quasi-polynomial algorithm, strongly suggesting GI is *not* NP-Complete.
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
      }

      // --- Module 6: Reductions ---
      function showReductions() {
        const template = `
                <div id="reduction-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 5: Reductions (Independent Set)</h2>

                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="reduction-what-is">What is a Reduction?</button>
                        <button class="tab-btn" data-tab="reduction-demo">Demo: IS $\\leftrightarrow$ VC</button>
                    </div>

                    <div id="reduction-what-is" class="tab-content active">
                        <h3 class="text-2xl font-semibold mb-3">What is a Polynomial-Time Reduction?</h3>
                        <p class="text-gray-300 mb-4 text-lg">
                            A **reduction** is a way to solve one problem using an algorithm for *another* problem.
                            A polynomial-time reduction ($L \\le_p L'$) is a "fast" transformation that turns an instance
                            of problem $L$ into an instance of $L'$.
                        </p>
                        
                        <h4 class="text-xl font-semibold mb-2">Why do this?</h4>
                        <ul class="list-disc list-inside space-y-2 text-gray-300 mb-4">
                            <li>
                                <span class="font-bold text-green-400">To Solve Problems:</span>
                                If you have a "magic" solver for $L'$, you can now solve $L$.
                            </li>
                            <li>
                                <span class="font-bold text-red-400">To Prove Hardness:</span>
                                If we know $L$ is "hard" (e.g., NP-Complete), then $L'$ must *also* be "hard." This is how Karp proved 21 problems were NP-Complete.
                            </li>
                        </ul>
                        
                        <p class="text-gray-300 mb-4">
                            Formally, $L \\le_p L'$ if there's a P-time
                            function $f$ that converts any instance $x$ of $L$ into an instance $f(x)$ of $L'$ such that:
                        </p>
                        <p class="text-gray-400 mb-4 bg-gray-800 p-4 rounded-lg text-center text-lg">
                            $x \\in L \\iff f(x) \\in L'$
                        </p>
                    </div>
                    
                    <div id="reduction-demo" class="tab-content">
                        <h3 class="text-2xl font-semibold mb-3">Demo: Independent Set $\\leftrightarrow$ Vertex Cover</h3>
                        <p class="text-gray-300 mb-4">
                            Let's show a simple reduction between two problems. This will prove they are equally hard.
                        </p>
                        
                        <h4 class="text-xl font-semibold mb-2">1. Define: Independent Set (IS)</h4>
                        <p class="text-gray-300 mb-4">
                            An **Independent Set** is a set of vertices $S \\subseteq V$ in a graph $G=(V,E)$
                            such that no two vertices in $S$ are connected by an edge.
                        </p>
                        
                        <h4 class="text-xl font-semibold mb-2">2. The "Aha!" Moment: The Reduction</h4>
                        <p class="text-gray-300 mb-4">
                            The reduction is based on this theorem:
                        </p>
                        <div class="p-4 bg-green-900 text-green-200 rounded-lg mb-4">
                            <strong class="text-lg">Theorem:</strong> In any graph $G=(V,E)$, a set $S \\subseteq V$ is an **Independent Set**
                            if and only if its complement, $V \\setminus S$, is a **Vertex Cover**.
                        </div>

                        <h4 class="text-xl font-semibold mb-2">Proof (IS $\\implies$ VC)</h4>
                        <ul class="list-disc list-inside space-y-2 text-gray-300 mb-4">
                            <li><strong>Assume:</strong> $S$ is an Independent Set.</li>
                            <li><strong>We must show:</strong> Its complement $C = V \\setminus S$ is a Vertex Cover.</li>
                            <li><strong>Proof:</strong> Take any edge $(u, v) \\in E$. Since $S$ is an IS, $u$ and $v$ *cannot* both be in $S$.</li>
                            <li>This means at least one of them *must not* be in $S$.</li>
                            <li>If at least one of $\\{u, v\\}$ is *not* in $S$, then at least one of them *must* be in its complement, $C$.</li>
                            <li>Since this is true for *every* edge, $C = V \\setminus S$ is a Vertex Cover.</li>
                        </ul>

                        <h4 class="text-xl font-semibold mb-2">Conclusion</h4>
                        <p class="text-gray-300 mb-4">
                            This proves $\\text{Independent Set} \\le_p \\text{Vertex Cover}$ (and vice-versa).
                            This also means $|MaxIS| + |MinVC| = |V|$.
                            <br><br>
                            The $O(2^n)$ algorithm in **Module 2** that finds a *minimum vertex cover*
                            is, by this reduction, *also* an algorithm for finding a *maximum independent set*.
                        </loc>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
        setupTabs("reduction-container");
      }

      // --- Module 7: PSPACE ---
      let tqbfStats = { opCount: 0, maxDepth: 0 };

      // Helper to evaluate CNF
      function evaluateCNF_JS(formula, assignments) {
        tqbfStats.opCount++;
        for (const clause of formula) {
          let clauseSatisfied = false;
          for (const literal of clause) {
            const varName = literal.replace("-", "");
            const isNegated = literal.startsWith("-");
            if (!(varName in assignments)) continue;
            const assignedVal = assignments[varName];
            if ((isNegated && !assignedVal) || (!isNegated && assignedVal)) {
              clauseSatisfied = true;
              break;
            }
          }
          if (!clauseSatisfied) return false;
        }
        return true;
      }
      // The core recursive TQBF solver
      function solveRecursive_JS(
        quantifiers,
        formula,
        assignments,
        index,
        currentDepth
      ) {
        tqbfStats.opCount++;
        if (currentDepth > tqbfStats.maxDepth) {
          tqbfStats.maxDepth = currentDepth;
        }

        // Base case: All variables assigned
        if (index === quantifiers.length) {
          return evaluateCNF_JS(formula, assignments);
        }

        const varInfo = quantifiers[index];
        const varName = varInfo.var;
        const quantifier = varInfo.q;

        if (quantifier === "") {
          // 'For All' player: must be true for BOTH
          let assignmentsTrue = { ...assignments, [varName]: true };
          let resTrue = solveRecursive_JS(
            quantifiers,
            formula,
            assignmentsTrue,
            index + 1,
            currentDepth + 1
          );
          let assignmentsFalse = { ...assignments, [varName]: false };
          let resFalse = solveRecursive_JS(
            quantifiers,
            formula,
            assignmentsFalse,
            index + 1,
            currentDepth + 1
          );
          return resTrue && resFalse;
        } else if (quantifier === "") {
          // 'Exists' player: must be true for AT LEAST ONE
          let assignmentsTrue = { ...assignments, [varName]: true };
          let resTrue = solveRecursive_JS(
            quantifiers,
            formula,
            assignmentsTrue,
            index + 1,
            currentDepth + 1
          );
          if (resTrue) return true; // Short-circuit

          let assignmentsFalse = { ...assignments, [varName]: false };
          let resFalse = solveRecursive_JS(
            quantifiers,
            formula,
            assignmentsFalse,
            index + 1,
            currentDepth + 1
          );
          return resFalse;
        }
      }

      function solveTQBF() {
        const output = document.getElementById("tqbf-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent = "Solving TQBF...";

        setTimeout(() => {
          try {
            const data = JSON.parse(document.getElementById("tqbf-json").value);
            const { quantifiers, formula } = data;
            tqbfStats = { opCount: 0, maxDepth: 0 };
            const startTime = performance.now();
            const result = solveRecursive_JS(quantifiers, formula, {}, 0, 0);
            const endTime = performance.now();

            if (result) {
              output.className =
                "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
              output.innerHTML = `<strong>Result: TRUE</strong>`;
            } else {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.innerHTML = `<strong>Result: FALSE</strong>`;
            }
            output.innerHTML += `<br>Time: ${(endTime - startTime).toFixed(
              2
            )} ms`;

            // Add stats
            output.innerHTML += `<div class="mt-4 pt-4 border-t border-gray-600">
                                <p><strong>Total Recursive Calls (Time):</strong> ${tqbfStats.opCount}</p>
                                <p><strong>Max Recursion Depth (Space):</strong> ${tqbfStats.maxDepth}</p>
                            </div>`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      function showPSPACE() {
        const template = `
                <div id="pspace-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 6: PSPACE-Complete (TQBF)</h2>
                    
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="pspace-what-is">What is PSPACE?</button>
                        <button class="tab-btn" data-tab="pspace-demo">Interactive TQBF Demo</button>
                    </div>

                    <div id="pspace-what-is" class="tab-content active">
                        <h3 class="text-2xl font-semibold mb-3">What is PSPACE?</h3>
                        <p class="text-gray-300 mb-4 text-lg">
                            **PSPACE** is the class of problems solvable by an algorithm that uses a **Polynomial amount of SPACE (memory)**,
                            regardless of how much *time* it takes.
                        </p>
                        <ul class="list-disc list-inside space-y-2 text-gray-300 mb-4">
                            <li>We know $\\text{P} \\subseteq \\text{NP} \\subseteq \\text{PSPACE}$.</li>
                            <li>We strongly suspect $\\text{P} \\neq \\text{PSPACE}$ and $\\text{NP} \\neq \\text{PSPACE}$, but it's not proven.</li>
                        </ul>
                        
                        <h4 class="text-xl font-semibold mb-2">TQBF: The PSPACE-Complete Problem</h4>
                        <p class="text-gray-300 mb-4">
                            The "hardest" problem in PSPACE is **TQBF (True Quantified Boolean Formulas)**.
                            It's like SAT, but with alternating "for all" ($\forall$) and "there exists" ($\exists$) quantifiers.
                        </p>
                        <p class="text-gray-400 mb-4 bg-gray-800 p-4 rounded-lg text-center text-lg">
                           $\\forall x \\exists y \\forall z \\dots \\phi(x, y, z, \\dots)$
                        </p>

                        <h4 class="text-xl font-semibold mb-2">Time vs. Space: The Key Lesson</h4>
                        <p class="text-gray-300 mb-4">
                            We can solve TQBF with a simple recursive algorithm (like the one in the demo).
                            <br>
                            - <span class="text-red-400 font-bold">Time Complexity:</span> The algorithm branches for every variable, leading to $O(2^n)$ time. **(Exponential!)**
                            <br>
                            - <span class="text-green-400 font-bold">Space Complexity:</span> The algorithm only needs to store the current path down the recursion tree. The depth of this tree is $n$. Therefore, it only uses $O(n)$ space. **(Polynomial!)**
                        </p>

                        <h4 class="text-xl font-semibold mb-2">Two-Player Game Analogy</h4>
                        <p class="text-gray-300 mb-4">
                            You can think of TQBF as a game:
                            - The **$\\exists$ player** wins if the formula is *True*.
                            - The **$\\forall$ player** wins if the formula is *False*.
                            <br>
                            The TQBF formula is *True* if the $\\exists$ player has a **winning strategy**, no matter what the $\\forall$ player does.
                        </p>
                    </div>

                    <div id="pspace-demo" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">Interactive TQBF Solver</h3>
                        <p class="text-gray-300 mb-4">
                            Note: The formula must be in CNF (an array of clauses).
                        </p>
                        
                        <label for="tqbf-json" class="block text-sm font-medium text-gray-300 mb-2">TQBF JSON:</label>
                        <textarea id="tqbf-json" rows="12" class="w-full p-2 bg-gray-900 text-gray-200 border border-gray-700 rounded-lg font-mono text-sm">
{
  "quantifiers": [
    {"var": "x", "q": ""},
    {"var": "y", "q": ""}
  ],
  "formula": [
    ["x", "y"],
    ["-x", "-y"]
  ]
}
                        </textarea>
                        
                        <button id="tqbf-solve-btn" class="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Solve TQBF (Exponential Time)</button>
                        
                        <div id="tqbf-output" class="mt-4 p-4 bg-gray-900 rounded-lg text-gray-300 min-h-[50px]">
                            Click "Solve TQBF" to see the result. The default formula $\\forall x \\exists y (x \\lor y) \\land (\\neg x \\lor \\neg y)$ should evaluate to **True**.
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
        setupTabs("pspace-container");

        // Wire up TQBF solver button
        document
          .getElementById("tqbf-solve-btn")
          .addEventListener("click", solveTQBF);
      }

      // --- Module 8: BPP (NEW) ---

      // Helper for modular exponentiation using BigInt
      // (base^exp) % mod
      function powMod(base, exp, mod) {
        let b = BigInt(base);
        let e = BigInt(exp);
        let m = BigInt(mod);
        if (m === 0n) throw "Cannot modulo by zero";

        let result = 1n;
        b = b % m;
        while (e > 0n) {
          if (e % 2n === 1n) result = (result * b) % m;
          e = e >> 1n; // e = e / 2
          b = (b * b) % m;
        }
        return result;
      }

      // Deterministic Primality Test (Trial Division)
      function solvePrimalityDeterministic_JS(n_big) {
        const n = Number(n_big); // Trial division works on standard numbers
        let opCount = 0;
        if (n < 2) return { isPrime: false, opCount: 0 };
        if (n === 2 || n === 3) return { isPrime: true, opCount: 1 };
        if (n % 2 === 0) return { isPrime: false, opCount: 1 };

        const limit = Math.sqrt(n);
        for (let i = 3; i <= limit; i += 2) {
          opCount++;
          if (n % i === 0) {
            return { isPrime: false, opCount: opCount };
          }
        }
        return { isPrime: true, opCount: opCount };
      }

      // Randomized Primality Test (Miller-Rabin)
      // Needs BigInt
      function solvePrimalityBPP_JS(n_big, k) {
        const n = BigInt(n_big);
        let opCount = 0;

        if (n <= 1n) return { isPrime: false, opCount: 0 };
        if (n <= 3n) return { isPrime: true, opCount: 0 };
        if (n % 2n === 0n) return { isPrime: false, opCount: 1 };

        // Write n-1 as 2^r * d
        let d = n - 1n;
        let r = 0n;
        while (d % 2n === 0n) {
          opCount++;
          d /= 2n;
          r++;
        }

        // Run k rounds
        for (let i = 0; i < k; i++) {
          opCount++;
          // Pick a random witness 'a'
          // We need a random BigInt between 2 and n-2
          const a = randomBigInt(2n, n - 2n);

          let x = powMod(a, d, n);
          if (x === 1n || x === n - 1n) continue;

          let isComposite = true;
          for (let j = 0n; j < r - 1n; j++) {
            opCount++;
            x = powMod(x, 2n, n);
            if (x === n - 1n) {
              isComposite = false;
              break;
            }
          }

          if (isComposite) {
            return { isPrime: false, opCount: opCount }; // Definitely composite
          }
        }
        return { isPrime: true, opCount: opCount }; // Probably prime
      }

      // Helper to get a random BigInt
      function randomBigInt(min, max) {
        // min and max are BigInts
        const range = max - min + 1n;
        const bits = range.toString(2).length;
        let num;
        do {
          num = 0n;
          for (let i = 0; i < bits; i++) {
            if (Math.random() < 0.5) {
              num |= 1n << BigInt(i);
            }
          }
        } while (num >= range); // Ensure it's in range
        return num + min;
      }

      function runDeterministicTest() {
        const output = document.getElementById("bpp-output-det");
        try {
          const n = BigInt(document.getElementById("bpp-number").value);
          if (n > 1000000000000000n) {
            // Safety rail for client-side JS
            throw new Error(
              "Number too large for JS trial division (max 10^15). This proves the algorithm is slow!"
            );
          }
          output.className =
            "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
          output.textContent = "Running trial division... This may take time.";

          setTimeout(() => {
            const startTime = performance.now();
            const { isPrime, opCount } = solvePrimalityDeterministic_JS(n);
            const endTime = performance.now();

            if (isPrime) {
              output.className =
                "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
              output.innerHTML = `<strong>Result: PRIME</strong>`;
            } else {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.innerHTML = `<strong>Result: COMPOSITE</strong>`;
            }
            output.innerHTML += `<br>Time: ${(endTime - startTime).toFixed(
              2
            )} ms<br>Operations: ~${opCount}`;
          }, 50);
        } catch (e) {
          output.className =
            "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
          output.textContent = `Error: ${e.message}`;
        }
      }

      function runRandomizedTest() {
        const output = document.getElementById("bpp-output-rand");
        try {
          const n = BigInt(document.getElementById("bpp-number").value);
          const k = Number(document.getElementById("bpp-k-slider").value);

          output.className =
            "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
          output.textContent = `Running Miller-Rabin with k=${k}...`;

          setTimeout(() => {
            const startTime = performance.now();
            const { isPrime, opCount } = solvePrimalityBPP_JS(n, k);
            const endTime = performance.now();

            if (isPrime) {
              output.className =
                "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
              output.innerHTML = `<strong>Result: PROBABLY PRIME</strong>`;
              output.innerHTML += `<br><span class="text-sm">Probability of error is < (1/4)^${k}</span>`;
            } else {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.innerHTML = `<strong>Result: COMPOSITE (100% certain)</strong>`;
            }
            output.innerHTML += `<br>Time: ${(endTime - startTime).toFixed(
              4
            )} ms<br>Operations: ~${opCount}`;
          }, 50);
        } catch (e) {
          output.className =
            "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
          output.textContent = `Error: ${e.message}`;
        }
      }

      function showBPP() {
        const template = `
                <div id="bpp-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 7: Randomized Algorithms (BPP)</h2>
                    
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="bpp-what-is">What is BPP?</button>
                        <button class="tab-btn" data-tab="bpp-demo">Interactive Demo (Primality)</button>
                    </div>

                    <div id="bpp-what-is" class="tab-content active">
                        <h3 class="text-2xl font-semibold mb-3">What is BPP?</h3>
                        <p class="text-gray-300 mb-4 text-lg">
                            **BPP** stands for **Bounded-error Probabilistic Polynomial time**.
                            <br><br>
                            It's the class of *decision problems* that can be solved by an algorithm that:
                        </p>
                        <ul class="list-disc list-inside space-y-2 text-gray-300 mb-4">
                            <li>Runs in **polynomial time**.</li>
                            <li>Is allowed to **"flip coins"** (use randomness).</li>
                            <li>Gives the correct "yes" or "no" answer with a high probability (e.g., > 2/3).</li>
                        </ul>
                        
                        <h4 class="text-xl font-semibold mb-2">The Key Example: Primality Testing</h4>
                        <p class="text-gray-300 mb-4">
                            **Problem:** Given a large number $n$, is it prime?
                            <br><br>
                            - <span class="font-bold text-red-400">Deterministic (Slow):</span> The simple **Trial Division** method (checking all divisors up to $\\sqrt{n}$)
                            is $O(\\sqrt{n})$. This is *exponential* in the number of bits ($b$) of $n$,
                            since $n \\approx 2^b$ and $\\sqrt{n} \\approx 2^{b/2}$.
                            <br><br>
                            - <span class="font-bold text-green-400">Randomized (Fast):</span> The **Miller-Rabin** algorithm is a BPP algorithm.
                            It runs in polynomial time ($O(k \cdot (\\log n)^3)$).
                            If it outputs "Composite," it is 100% correct.
                            If it outputs "Probably Prime," it has a small chance ($< (1/4)^k$) of being wrong.
                        </p>
                        
                        <h4 class="text-xl font-semibold mb-2">P vs. BPP</h4>
                        <p class="text-gray-300 mb-4">
                            We know $\\text{P} \\subseteq \\text{BPP}$. The open question is: **Does $\\text{P} = \\text{BPP}$?**
                            <br>
                            Most researchers believe **YES**, as many BPP problems have been "derandomized".
                        </p>
                        <div class="paper-info">
                            <strong>The AKS Primality Test (2002)</strong>
                            <br><br>
                            For decades, Primality Testing was the most-cited example of a problem in BPP but not known to be in P.
                            In 2002, Agrawal, Kayal, and Saxena (AKS) proved that **PRIMES is in P**.
                            They found the first-ever deterministic, polynomial-time algorithm for primality testing.
                        </div>
                    </div>

                    <div id="bpp-demo" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">Interactive Demo: Primality Testing</h3>
                        <p class="text-gray-300 mb-4">
                           Compare the 'slow' deterministic algorithm with the 'fast' randomized one.
                           (Note: Trial division is capped at $10^{15}$ in JS to prevent browser crashing).
                        </p>
                        
                        <label for="bpp-number" class="block text-sm font-medium text-gray-300 mb-2">Number to Test (n):</label>
                        <input type="text" id="bpp-number" value="1000000000000037" class="w-full p-2 bg-gray-900 text-gray-200 border border-gray-700 rounded-lg">
                        
                        <hr class="my-6 border-gray-700">

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <h4 class="text-lg font-semibold mb-2">1. Deterministic (Trial Division)</h4>
                                <p class="text-sm text-gray-400 mb-2">Complexity: $O(\\sqrt{n})$ (Exponential)</p>
                                <button id="bpp-det-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Test (Deterministic)</button>
                                <div id="bpp-output-det" class="mt-4 p-4 bg-gray-900 rounded-lg text-gray-300 min-h-[50px]">
                                    Output for deterministic test.
                                </div>
                            </div>
                            
                            <div>
                                <h4 class="text-lg font-semibold mb-2">2. Randomized (Miller-Rabin)</h4>
                                <p class="text-sm text-gray-400 mb-2">Complexity: $O(k \cdot (\\log n)^3)$ (Polynomial)</p>
                                
                                <label for="bpp-k-slider" class="block text-sm font-medium text-gray-300">Certainty Rounds (k): <span id="bpp-k-value">10</span></label>
                                <input type="range" id="bpp-k-slider" min="1" max="40" value="10" class="w-full">
                                
                                <button id="bpp-rand-btn" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Test (Randomized)</button>
                                
                                <div id="bpp-output-rand" class="mt-4 p-4 bg-gray-900 rounded-lg text-gray-300 min-h-[50px]">
                                    Output for randomized test.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
        setupTabs("bpp-container");

        // Wire up BPP buttons
        document
          .getElementById("bpp-det-btn")
          .addEventListener("click", runDeterministicTest);
        document
          .getElementById("bpp-rand-btn")
          .addEventListener("click", runRandomizedTest);
        document
          .getElementById("bpp-k-slider")
          .addEventListener(
            "input",
            (e) =>
              (document.getElementById("bpp-k-value").textContent =
                e.target.value)
          );
      }

      // --- Initialization ---

      // Setup nav link listeners
      document.querySelectorAll("nav a").forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          const moduleName = e.currentTarget.dataset.module;
          showModule(moduleName);
        });
      });

      // Show the home module by default
      showModule("home");
    </script>
  </body>
</html>
