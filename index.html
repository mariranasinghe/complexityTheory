<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Complexity Explorer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Chart.js for the visualizer -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Load MathJax to render LaTeX equations -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
          processEscapes: true,
        },
        startup: {
          ready: () => {
            MathJax.startup.defaultReady();
            MathJax.startup.promise.then(() => {
              console.log("MathJax all set!");
            });
          },
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>

    <style>
      /* Custom styles for a dark-mode app */
      body {
        font-family: "Inter", sans-serif;
        color: #e0e0e0;
      }
      /* Style for the active nav link */
      .nav-link.active {
        background-color: #111827; /* gray-900 */
        color: #38bdf8; /* sky-400 */
      }
      /* Custom scrollbar for module content */
      .module-content {
        overflow-y: auto;
        max-height: 100vh;
      }
      /* Webkit scrollbar styles */
      .module-content::-webkit-scrollbar {
        width: 8px;
      }
      .module-content::-webkit-scrollbar-track {
        background: #1f2937; /* gray-800 */
      }
      .module-content::-webkit-scrollbar-thumb {
        background: #4b5563; /* gray-600 */
        border-radius: 4px;
      }
      .module-content::-webkit-scrollbar-thumb:hover {
        background: #6b7280; /* gray-500 */
      }

      /* Tab styles */
      .tab-btn {
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        background-color: #374151; /* gray-700 */
        color: #d1d5db; /* gray-300 */
        font-weight: 500;
        cursor: pointer;
      }
      .tab-btn.active {
        background-color: #38bdf8; /* sky-400 */
        color: #1e293b; /* gray-800 */
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }

      /* Popover/Details styles for Module 4 */
      details.popover-def {
        display: inline;
        cursor: pointer;
      }
      details.popover-def summary {
        display: inline-block;
        background-color: #1d4ed8; /* blue-700 */
        color: #e0e7ff; /* blue-100 */
        padding: 2px 8px;
        border-radius: 6px;
        font-size: 0.9em;
        font-weight: 500;
        -webkit-user-select: none; /* Safari */
        user-select: none;
      }
      details.popover-def summary::-webkit-details-marker {
        display: none; /* Hide the disclosure triangle */
      }
      details.popover-def:hover summary {
        background-color: #2563eb; /* blue-600 */
      }
      details.popover-def div {
        position: absolute;
        width: 300px;
        background-color: #1f2937; /* gray-800 */
        border: 1px solid #374151; /* gray-700 */
        border-radius: 8px;
        padding: 1rem;
        margin-top: 8px;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        z-index: 10;
      }
    </style>
  </head>
  <body class="h-full flex">
    <!-- Sidebar Navigation -->
    <nav class="w-64 h-full bg-gray-800 p-4 space-y-2 fixed">
      <h2 class="text-2xl font-bold text-sky-400 mb-6">Complexity Explorer</h2>
      <a
        href="#"
        data-module="home"
        class="nav-link active block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >Home</a
      >
      <a
        href="#"
        data-module="visualizer"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >1. Time Complexity Visualizer</a
      >
      <a
        href="#"
        data-module="vertexCover"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >2. P vs. NP (Vertex Cover)</a
      >
      <a
        href="#"
        data-module="tsp"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >3. NP-Complete (TSP)</a
      >
      <a
        href="#"
        data-module="openProblems"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >4. Open Problems & The Future</a
      >
      <!-- NEW MODULE LINK -->
      <a
        href="#"
        data-module="reductions"
        class="nav-link block w-full text-left px-4 py-2 rounded-lg text-gray-200 hover:bg-gray-700"
        >5. Reductions (IS to VC)</a
      >
    </nav>

    <!-- Main Content Area -->
    <main class="flex-1 ml-64 h-full">
      <div id="module-content" class="module-content p-8 h-full">
        <!-- Dynamic content will be loaded here -->
      </div>
    </main>

    <script>
      // --- Core Application Logic ---

      // Global store for chart instances to destroy them
      let charts = {};

      const modules = {
        home: showHome,
        visualizer: showVisualizer,
        vertexCover: showVertexCover,
        tsp: showTSP,
        openProblems: showOpenProblems,
        reductions: showReductions, // NEW MODULE
      };

      // Simple router to show a module
      function showModule(moduleName) {
        // Destroy any existing charts before loading new content
        destroyCharts();

        const moduleFunction = modules[moduleName];
        if (moduleFunction) {
          moduleFunction();
          // Update active nav link
          document.querySelectorAll("nav a").forEach((a) => {
            a.classList.remove("active", "bg-gray-900", "text-sky-400");
            if (a.dataset.module === moduleName) {
              a.classList.add("active", "bg-gray-900", "text-sky-400");
            }
          });
          // After content is loaded, tell MathJax to re-scan the page
          if (window.MathJax) {
            MathJax.typesetPromise();
          }
        }
      }

      function destroyCharts() {
        Object.values(charts).forEach((chart) => chart.destroy());
        charts = {};
      }

      // --- Module 1: Home Screen ---
      function showHome() {
        const template = `
                <div class="text-center">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Welcome to the Complexity Explorer!</h2>
                    <p class="text-lg text-gray-300 mb-8">
                        An interactive tool for university students to get an intuitive feel for P, NP, and NP-Complete problems.
                    </p>
                </div>

                <div class="flex flex-wrap -mx-4 mt-8">
                    <!-- Column 1: What is P? -->
                    <div class="w-full lg:w-1/2 px-4 mb-4 md:mb-0">
                        <div class="bg-gray-800 p-6 rounded-lg h-full">
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">What is Complexity Theory?</h3>
                            <p class="text-gray-300 mb-4">
                                It's the study of how "hard" computational problems are. We classify problems by the *resources* (usually time or memory) required to solve them as the input size 'n' grows.
                            </p>
                            
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">The Big Classes: P vs. NP</h3>
                            <ul class="space-y-3">
                                <li>
                                    <span class="font-bold text-green-400">P (Polynomial Time):</span>
                                    <p class="text-sm text-gray-300">
                                        "Efficiently solvable" problems. We can find a solution in polynomial time.
                                        <br>Example: Sorting an array ($O(n \\log n)$).
                                        <br>Formal: $Time \\le O(n^k) \\text{ for some constant } k.$
                                    </p>
                                </li>
                                <li>
                                    <span class="font-bold text-yellow-400">NP (Nondeterministic Polynomial Time):</span>
                                    <p class="text-sm text-gray-300">
                                        "Efficiently verifiable" problems. If given a potential solution, we can *check* if it's correct in polynomial time.
                                    </p>
                                </li>
                                <li>
                                    <span class="font-bold text-red-400">NP-Complete:</span>
                                    <p class="text-sm text-gray-300">
                                        The "hardest" problems in NP. They are in NP, and every other NP problem can be reduced to them.
                                        <br>Formally: $L \\le_p L_{npc}$ for all $L \\in \\text{NP}$.
                                        <br>If you solve one efficiently, you solve them all!
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </div>

                    <!-- Column 2: How to Use -->
                    <div class="w-full lg:w-1/2 px-4">
                        <div class="bg-gray-800 p-6 rounded-lg h-full">
                            <h3 class="text-xl font-semibold text-gray-200 mb-3">How To Use This Tool</h3>
                            <p class="text-gray-300 mb-4">Follow these steps to build an intuition for complexity:</p>
                            <ol class="list-decimal list-inside text-gray-300 space-y-4">
                                <li>
                                    <span class="font-bold text-cyan-400">Explore the Charts:</span>
                                    Go to <span class="font-semibold">Module 1</span>. Use the two charts to see the difference between polynomial ($O(n^2)$) and exponential ($O(2^n)$) growth.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Feel the P vs. NP Gap:</span>
                                    Go to <span class="font-semibold">Module 2 (Vertex Cover)</span>.
                                    - Click 'Verify'. It's instant ($O(|V| \cdot |E|)$).
                                    - Click 'Solve'. For a small graph (n=10), it's fast. Try a larger one (n=18). You will *feel* the exponential $O(2^n \cdot |E|)$ delay.
                                </li>
                                <!-- NEW STEP -->
                                <li>
                                    <span class="font-bold text-cyan-400">Experience Reductions:</span>
                                    Go to <span class="font-semibold">Module 5</span>. Learn how the **Independent Set** problem is just a "mirror image" of **Vertex Cover**. This proves that if you can solve one, you can solve the other, making them equally hard.
                                </li>
                                <li>
                                    <span class="font-bold text-cyan-400">Experience Factorial Explosion:</span>
                                    Go to <span class="font-semibold">Module 3 (TSP)</span>.
                                    - Generate 9 cities. The solver takes a few seconds ($9!$).
                                    - Generate 10 cities. The time increases 10-fold ($10!$). *That* is the $O(n!)$ factorial wall.
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>

                <!-- Foundational Research -->
                <div class="mt-8 pt-6 border-t border-gray-700">
                    <h3 class="text-2xl font-semibold text-cyan-400 mb-4">Learn More: Foundational Research</h3>
                    <p class="text-gray-300 mb-6">
                        The concepts in this tool are built on decades of research. These are some of the most important papers in the field:
                    </p>
                    <div class="space-y-4 text-gray-300">
                        <!-- UPDATED SUMMARY 1 -->
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Cook, S. A. (1971). "The complexity of theorem-proving procedures."</p>
                            <p class="text-sm mt-1">
                                **Summary:** This is the foundational paper that birthed the field of NP-Completeness. Cook proved that the **Satisfiability (SAT)** problem has a special property: *any* problem in NP can be "reduced" to it. This means if you could solve SAT efficiently, you could solve *every* problem in NP efficiently. He called this property "NP-Complete."
                            </p>
                        </div>
                        <!-- UPDATED SUMMARY 2 -->
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Karp, R. M. (1972). "Reducibility among combinatorial problems."</p>
                            <p class="text-sm mt-1">
                                **Summary:** Karp's paper showed that Cook's discovery wasn't a fluke. He took the idea of "reducibility" and ran with it, identifying 21 other famous, seemingly unrelated problems (including Vertex Cover and TSP) that were also NP-Complete. This established that a vast "web" of problems were all fundamentally the same hard problem, just in different disguises.
                            </p>
                        </div>
                        <!-- UPDATED SUMMARY 3 -->
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="font-semibold text-gray-200">Garey, M. R., & Johnson, D. S. (1979). "Computers and Intractability: A Guide to the Theory of NP-Completeness."</p>
                            <p class="text-sm mt-1">
                                **Summary:** This is the "bible" of NP-Completeness. It's not a research paper but a comprehensive textbook that standardized the theory, provided a huge catalog of NP-Complete problems, and gave computer scientists a practical 'how-to' manual for identifying and dealing with intractable problems in their own work.
                            </p>
                        </div>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;
      }

      // --- Module 2: Time Complexity Visualizer ---
      function showVisualizer() {
        const template = `
                <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 1: Time Complexity Visualizer</h2>
                <p class="text-lg text-gray-300 mb-6">
                    A single chart can't show everything. Here are two charts to understand the two key scenarios.
                </p>
                
                <!-- Chart 1: Polynomial -->
                <h3 class="text-xl font-semibold text-gray-200 mb-3">Chart 1: The 'Fast' Algorithms (Polynomial Time)</h3>
                <p class="text-gray-300 mb-4">
                    This chart shows *only* the "fast" algorithms on a **linear scale**.
                    This lets you see the real, practical difference between $O(n)$, $O(n \\log n)$, and $O(n^2)$.
                </p>
                <div class="bg-gray-800 p-6 rounded-lg mb-8" style="height: 40vh;">
                    <canvas id="complexity-chart-p"></canvas>
                </div>

                <!-- Chart 2: P vs NP -->
                <h3 class="text-xl font-semibold text-gray-200 mb-3">Chart 2: The 'Explosion' (P vs. NP)</h3>
                <p class="text-gray-300 mb-4">
                    This chart compares $O(n^2)$ to the "slow" ones on a **logarithmic scale**.
                    Notice: 1. At small 'n', the lines are jumbled. 2. After $n=20$, $O(n!)$ disappears as it hits infinity (the "factorial wall").
                </p>
                <div class="bg-gray-800 p-6 rounded-lg" style="height: 40vh;">
                    <canvas id="complexity-chart-np"></canvas>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // --- Chart.js Logic ---
        const chartOptions = (title, isLog) => ({
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              type: isLog ? "logarithmic" : "linear",
              beginAtZero: !isLog,
              grid: { color: "#4b5563" },
              ticks: {
                color: "#e0e0e0",
                callback: (value) =>
                  isLog ? Number(value).toExponential(0) : value,
              },
            },
            x: {
              grid: { color: "#4b5563" },
              ticks: { color: "#e0e0e0" },
            },
          },
          plugins: {
            legend: { labels: { color: "#e0e0e0" } },
            title: {
              display: true,
              text: title,
              color: "#e0e0e0",
              font: { size: 16 },
            },
          },
          interaction: {
            intersect: false,
            mode: "index",
          },
          animation: false,
        });

        // Chart 1: Polynomial
        const nRangeP = Array.from({ length: 100 }, (_, i) => i + 1);
        const dataP = {
          labels: nRangeP,
          datasets: [
            {
              label: "O(n)",
              data: nRangeP.map((n) => n),
              borderColor: "#4ade80",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n log n)",
              data: nRangeP.map((n) => n * Math.log2(n)),
              borderColor: "#22d3ee",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n^2)",
              data: nRangeP.map((n) => n ** 2),
              borderColor: "#facc15",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
          ],
        };
        const ctxP = document
          .getElementById("complexity-chart-p")
          .getContext("2d");
        charts["chartP"] = new Chart(ctxP, {
          type: "line",
          data: dataP,
          options: chartOptions("Polynomial Growth (n=1 to 100)", false),
        });

        // Chart 2: Exponential
        const nRangeNP = Array.from({ length: 25 }, (_, i) => i + 1);
        const factorial = (n) =>
          n > 20
            ? Infinity
            : Array.from({ length: n }, (_, i) => i + 1).reduce(
                (a, b) => a * b,
                1
              );
        const dataNP = {
          labels: nRangeNP,
          datasets: [
            {
              label: "O(n^2)",
              data: nRangeNP.map((n) => n ** 2),
              borderColor: "#facc15",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(2^n)",
              data: nRangeNP.map((n) => 2 ** n),
              borderColor: "#f87171",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
            {
              label: "O(n!)",
              data: nRangeNP.map((n) => factorial(n)),
              borderColor: "#f472b6",
              borderWidth: 2,
              fill: false,
              pointRadius: 0,
            },
          ],
        };
        const ctxNP = document
          .getElementById("complexity-chart-np")
          .getContext("2d");
        charts["chartNP"] = new Chart(ctxNP, {
          type: "line",
          data: dataNP,
          options: chartOptions("The P vs. NP 'Explosion' (n=1 to 25)", true),
        });
      }

      // --- Helper: Tab switching logic ---
      function setupTabs(containerId) {
        const container = document.getElementById(containerId);
        const tabButtons = container.querySelectorAll(".tab-btn");
        const tabContents = container.querySelectorAll(".tab-content");

        tabButtons.forEach((button) => {
          button.addEventListener("click", () => {
            // Deactivate all
            tabButtons.forEach((btn) => btn.classList.remove("active"));
            tabContents.forEach((content) =>
              content.classList.remove("active")
            );

            // Activate clicked
            button.classList.add("active");
            const contentId = button.dataset.tab;
            document.getElementById(contentId).classList.add("active");
          });
        });
      }

      // --- Helper: Graph Generators ---
      function generateRandomGraph(n, p) {
        let adjList = {};
        for (let i = 0; i < n; i++) adjList[i] = [];
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            if (Math.random() < p) {
              adjList[i].push(j);
              adjList[j].push(i);
            }
          }
        }
        return JSON.stringify(adjList, null, 2);
      }
      function generateCompleteGraph(n) {
        let adjList = {};
        for (let i = 0; i < n; i++) {
          adjList[i] = [];
          for (let j = 0; j < n; j++) {
            if (i !== j) adjList[i].push(j);
          }
        }
        return JSON.stringify(adjList, null, 2);
      }
      function generateRandomCities(n) {
        let cities = {};
        for (let i = 0; i < n; i++) {
          cities[String.fromCharCode(65 + i)] = {
            x: Math.floor(Math.random() * 101),
            y: Math.floor(Math.random() * 101),
          };
        }
        return JSON.stringify(cities, null, 2);
      }

      // --- Module 3: Vertex Cover Problem ---
      function showVertexCover() {
        const template = `
                <div id="vc-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 2: P vs. NP (Vertex Cover)</h2>
                    
                    <!-- Tab Buttons -->
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="vc-demo">Interactive Demo</button>
                        <button class="tab-btn" data-tab="vc-what-is">What is Vertex Cover?</button>
                        <button class="tab-btn" data-tab="vc-concepts">Key Concepts</button>
                    </div>

                    <!-- Tab Content: Demo -->
                    <div id="vc-demo" class="tab-content active">
                        <p class="text-lg text-gray-300 mb-6">
                            Experiment with the P vs. NP gap. **Verify** a solution (fast) vs. **Solve** for a solution (slow).
                        </p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- Left Column: Demo -->
                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="text-xl font-semibold mb-4">Graph Generators</h3>
                                <div class="flex space-x-2 mb-4">
                                    <button id="vc-gen-random" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">Random (n=10)</button>
                                    <button id="vc-gen-complete" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">Complete (K5)</button>
                                    <button id="vc-gen-large" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">Larger (n=15)</button>
                                </div>
                                
                                <label class="block text-sm font-medium text-gray-300">Graph (JSON Adjacency List)</label>
                                <textarea id="vc-graph" class="w-full h-32 bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700">{"A": ["B", "C"], "B": ["A", "C", "D"], "C": ["A", "B", "D"], "D": ["B", "C", "E"], "E": ["D"]}</textarea>
                                
                                <div id="vc-output" class="mt-4 p-4 bg-gray-900 rounded-lg text-gray-300 min-h-[50px]"></div>
                            </div>

                            <!-- Right Column: Actions -->
                            <div class="bg-gray-800 p-6 rounded-lg space-y-6">
                                <!-- Verify Action -->
                                <div>
                                    <h3 class="text-xl font-semibold mb-2 text-green-400">1. Verify a Solution (Fast - P)</h3>
                                    <p class="text-sm text-gray-400 mb-3">Give me a set, I'll check if it's a cover.</p>
                                    <label class="block text-sm font-medium text-gray-300">Proposed Cover (e.g., A,D)</label>
                                    <input id="vc-solution" type="text" class="w-full bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700" value="B,C,E">
                                    <button id="vc-verify-btn" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Verify (Polynomial Time)</button>
                                </div>

                                <!-- Solve Action -->
                                <div>
                                    <h3 class="text-xl font-semibold mb-2 text-red-400">2. Find Smallest Solution (Slow - NP)</h3>
                                    <p class="text-sm text-gray-400 mb-3">Find the *smallest* cover. This is the hard part!</p>
                                    <button id="vc-solve-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Find Smallest Cover (Brute Force)</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab Content: What is VC? -->
                    <div id="vc-what-is" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">What is Vertex Cover?</h3>
                        <p class="mb-4">
                            A <span class="font-bold text-sky-400">Vertex Cover</span> is a subset of vertices in a graph such that every edge in the graph
                            is "covered" (i.e., at least one of its two endpoints is in the subset).
                        </p>
                        <h4 class="text-lg font-semibold mb-2">Formal Definition</h4>
                        <p class="mb-2">Given a graph $G = (V, E)$, where $V$ is the set of vertices and $E$ is the set of edges. A vertex cover is a subset $V' \\subseteq V$ such that for every edge $(u, v) \\in E$, at least one of $u$ or $v$ is in $V'$.</p>
                        <p class="mb-4 p-4 bg-gray-900 rounded-lg text-cyan-300">$$V' \\subseteq V \\text{ s.t. } \\forall (u, v) \\in E, \\{u, v\\} \\cap V' \\neq \\emptyset$$</p>
                        
                        <h4 class="text-lg font-semibold mb-2">The NP-Complete Problem</h4>
                        <p class="mb-2">The *optimization* problem is "Find the *minimum* vertex cover," (i.e., find a $V'$ that has the smallest possible size $|V'|$).</p>
                        <p class="mb-2">The *decision* problem (which is proven to be NP-Complete) is **K-VERTEX-COVER**: "Given a graph $G$ and an integer $k$, does $G$ have a vertex cover of size $k$ or less?"</p>
                        <p class="mb-4 p-4 bg-gray-900 rounded-lg text-cyan-300">$$\\text{Does a } V' \\subseteq V \\text{ exist s.t. } |V'| \\le k \\text{ and } V' \\text{ is a VC for } G?$$</p>
                        
                        <h4 class="text-lg font-semibold mb-2">The P vs. NP Demonstration</h4>
                        <ul class="list-disc list-inside space-y-2">
                            <li><span class="font-bold text-green-400">Verifying is FAST (in P):</span> If you give me a proposed cover $V'$, I can check if it's valid in polynomial time. (Time: $O(|V| + |E|)$).</li>
                            <li><span class="font-bold text-red-400">Finding is SLOW (in NP):</span> Finding the *smallest* cover is hard. The brute-force way is to check every possible subset $V'$ of $V$. There are $2^{|V|}$ such subsets. Total time: $O(2^{|V|} \cdot |E|)$.</li>
                        </ul>
                    </div>
                    
                    <!-- Tab Content: Key Concepts -->
                    <div id="vc-concepts" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-4">Key Concepts</h3>
                        <dl class="space-y-4">
                            <div>
                                <dt class="font-bold text-sky-400">Graph $G=(V, E)$</dt>
                                <dd>A graph is a mathematical structure used to model pairwise relations. It consists of a set of **Vertices (V)** (or nodes) and a set of **Edges (E)** (or links) that connect pairs of vertices.</dd>
                            </div>
                            <div>
                                <dt class="font-bold text-sky-400">Adjacency List</dt>
                                <dd>A way to represent a graph. It's a collection where each vertex has a list of all the other vertices it is connected to (its 'neighbors'). This is what the JSON in the demo represents.</dd>
                            </div>
                            <div>
                                <dt class="font-bold text-sky-400">Brute Force</dt>
                                <dd>An algorithm design technique that consists of systematically checking every possible solution to a problem until the correct or best one is found. This is often simple to implement but very slow.</dd>
                            </div>
                            <div>
                                <dt class="font-bold text-sky-400">Decision Problem vs. Optimization Problem</dt>
                                <dd>An **Optimization Problem** asks for the *best* solution (e.g., "Find the *smallest* vertex cover"). A **Decision Problem** asks a "yes/no" question (e.g., "Is there a vertex cover of size *k* or less?"). NP-Completeness is formally defined using decision problems.</dd>
                            </div>
                        </dl>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Event Listeners
        document
          .getElementById("vc-verify-btn")
          .addEventListener("click", verifyVertexCover);
        document
          .getElementById("vc-solve-btn")
          .addEventListener("click", solveVertexCover);

        // Wire up tab switching
        setupTabs("vc-container");

        // Wire up generators
        const graphText = document.getElementById("vc-graph");
        document
          .getElementById("vc-gen-random")
          .addEventListener("click", () => {
            graphText.value = generateRandomGraph(10, 0.3);
          });
        document
          .getElementById("vc-gen-complete")
          .addEventListener("click", () => {
            graphText.value = generateCompleteGraph(5);
          });
        document
          .getElementById("vc-gen-large")
          .addEventListener("click", () => {
            graphText.value = generateRandomGraph(15, 0.2);
          });
      }

      function verifyVertexCover() {
        const output = document.getElementById("vc-output");
        try {
          const adjList = JSON.parse(document.getElementById("vc-graph").value);
          const solutionInput = document.getElementById("vc-solution").value;
          const solutionSet = new Set(
            solutionInput
              .split(",")
              .map((s) => s.trim())
              .filter(Boolean)
          );

          const edges = new Set();
          for (const u in adjList) {
            for (const v of adjList[u]) {
              // Use numbers for sorting if they are numbers, else string sort
              const uKey = isNaN(Number(u)) ? u : Number(u);
              const vKey = isNaN(Number(v)) ? v : Number(v);
              const edge = [uKey, vKey]
                .sort((a, b) => String(a).localeCompare(String(b)))
                .join("-");
              edges.add(edge);
            }
          }

          let uncovered = [];
          let opCount = 0;
          for (const edge of edges) {
            opCount++;
            const [u, v] = edge.split("-");
            if (!solutionSet.has(u) && !solutionSet.has(v)) {
              uncovered.push(edge);
            }
          }

          if (uncovered.length === 0) {
            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>SUCCESS:</strong> This is a valid vertex cover.<br>(~${opCount} operations, P-time)`;
          } else {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>FAILED:</strong> This set does not cover:<br>${uncovered.join(
              ", "
            )}<br>(~${opCount} operations, P-time)`;
          }
        } catch (e) {
          output.className =
            "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
          output.textContent = `Error: ${e.message}`;
        }
      }

      function solveVertexCover() {
        const output = document.getElementById("vc-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent = "Solving (brute force)... This may take a moment.";

        setTimeout(() => {
          try {
            const adjList = JSON.parse(
              document.getElementById("vc-graph").value
            );
            const vertices = Object.keys(adjList);
            const n = vertices.length;

            if (n > 20) {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.textContent =
                "Error: Graph is too large for client-side brute force (n > 20). This demonstrates exponential complexity!";
              return;
            }

            const edges = new Set();
            for (const u in adjList) {
              for (const v of adjList[u]) {
                const uKey = isNaN(Number(u)) ? u : Number(u);
                const vKey = isNaN(Number(v)) ? v : Number(v);
                const edge = [uKey, vKey]
                  .sort((a, b) => String(a).localeCompare(String(b)))
                  .join("-");
                edges.add(edge);
              }
            }

            let smallestCover = null;
            let opCount = 0;

            for (let i = 0; i < 1 << n; i++) {
              opCount++;
              const subset = new Set();
              for (let j = 0; j < n; j++) {
                if ((i >> j) & 1) {
                  subset.add(vertices[j]);
                }
              }

              let isCover = true;
              for (const edge of edges) {
                opCount++;
                const [u, v] = edge.split("-");
                if (!subset.has(u) && !subset.has(v)) {
                  isCover = false;
                  break;
                }
              }

              if (isCover) {
                if (
                  smallestCover === null ||
                  subset.size < smallestCover.size
                ) {
                  smallestCover = subset;
                }
              }
            }

            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>SOLVED:</strong> Smallest cover is {${[
              ...smallestCover,
            ].join(", ")}} (Size: ${
              smallestCover.size
            }).<br>(~${opCount} operations, $O(2^n)$)`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // --- Module 4: Traveling Salesperson Problem (TSP) ---
      function showTSP() {
        const template = `
                <div id="tsp-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 3: NP-Complete (Traveling Salesperson)</h2>
                    
                    <!-- Tab Buttons -->
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="tsp-demo">Interactive Demo</button>
                        <button class="tab-btn" data-tab="tsp-what-is">What is TSP?</button>
                        <button class="tab-btn" data-tab="tsp-concepts">Key Concepts</button>
                    </div>

                    <!-- Tab Content: Demo -->
                    <div id="tsp-demo" class="tab-content active">
                        <p class="text-lg text-gray-300 mb-6">
                            Find the shortest route that visits each city once. This is $O(n!)$, which is even worse than $O(2^n)$!
                        </p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- Left Column: Demo -->
                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="text-xl font-semibold mb-4">City Generators</h3>
                                <div class="flex space-x-2 mb-4">
                                    <button id="tsp-gen-5" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">5 Random Cities</button>
                                    <button id="tsp-gen-8" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">8 Random Cities</button>
                                    <button id="tsp-gen-9" class="flex-1 bg-sky-600 hover:bg-sky-700 text-white text-sm font-bold py-2 px-3 rounded-lg">9 Random Cities</button>
                                </div>

                                <label class="block text-sm font-medium text-gray-300">Cities (JSON with x, y coords)</label>
                                <textarea id="tsp-cities" class="w-full h-32 bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700">{"A": {"x": 0, "y": 0}, "B": {"x": 10, "y": 5}, "C": {"x": 5, "y": 10}, "D": {"x": 15, "y": 0}}</textarea>
                                
                                <div id="tsp-output" class="mt-4 p-4 bg-gray-900 rounded-lg text-gray-300 min-h-[50px]"></div>
                            </div>

                            <!-- Right Column: Actions -->
                            <div class="bg-gray-800 p-6 rounded-lg space-y-6">
                                <!-- Verify Action -->
                                <div>
                                    <h3 class="text-xl font-semibold mb-2 text-green-400">1. Verify a Tour Length (Fast - P)</h3>
                                    <p class="text-sm text-gray-400 mb-3">Give me a tour, I'll calculate its length.</p>
                                    <label class="block text-sm font-medium text-gray-300">Proposed Tour (e.g., A,B,C,D,A)</label>
                                    <input id="tsp-tour" type="text" class="w-full bg-gray-900 text-gray-200 p-2 rounded-lg border border-gray-700" value="A,C,B,D,A">
                                    <button id="tsp-verify-btn" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Verify (Polynomial Time)</button>
                                </div>

                                <!-- Solve Action -->
                                <div>
                                    <h3 class="text-xl font-semibold mb-2 text-red-400">2. Find Shortest Tour (Very Slow - NP)</h3>
                                    <p class="text-sm text-gray-400 mb-3">Find the *shortest* tour. (Max n=9 for demo)</p>
                                    <button id="tsp-solve-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Find Shortest Tour (Brute Force)</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab Content: What is TSP? -->
                    <div id="tsp-what-is" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">What is the Traveling Salesperson (TSP)?</h3>
                        <p class="mb-4">
                            Given a list of cities and the distances between them, what is the <span class="font-bold text-sky-400">shortest possible route</span> 
                            that visits each city exactly once and returns to the origin city?
                        </p>
                        <h4 class="text-lg font-semibold mb-2">Formal Definition</h4>
                        <p class="mb-2">Given a complete weighted graph $G = (V, E, w)$, where $w(e)$ is the "weight" or "distance" of edge $e$. Find a **Hamiltonian cycle** (a tour that visits every vertex $v \\in V$ exactly once) with the minimum total weight.</p>
                        <p class="mb-4 p-4 bg-gray-900 rounded-lg text-cyan-300">Find a permutation $\\pi$ of vertices $V=\\{v_1, ..., v_n\\}$ that minimizes:
                            $$w(v_{\\pi(n)}, v_{\\pi(1)}) + \\sum_{i=1}^{n-1} w(v_{\\pi(i)}, v_{\\pi(i+1)})$$
                        </p>
                        
                        <h4 class="text-lg font-semibold mb-2">The NP-Complete Problem</h4>
                        <p class="mb-2">The *decision* problem (which is NP-Complete) is **K-TSP**: "Given a graph $G$, distances $w$, and an integer $k$, does $G$ have a tour with a total weight less than or equal to $k$?"</p>
                        
                        <h4 class="text-lg font-semibold mb-2">The P vs. NP Demonstration</h4>
                        <ul class="list-disc list-inside space-y-2">
                            <li><span class="font-bold text-green-400">Verifying is FAST (in P):</span> If you give me a path (a tour $\\pi$), I can quickly add up the distances ($O(n)$).</li>
                            <li><span class="font-bold text-red-400">Finding is SLOW (in NP):</span> Finding the *shortest* tour is hard. The brute-force way is to check every possible permutation (ordering) of cities. There are $(n-1)!$ possible tours. Total time: $O(n!)$.</li>
                        </ul>
                    </div>

                    <!-- Tab Content: Key Concepts -->
                    <div id="tsp-concepts" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-4">Key Concepts</h3>
                        <dl class="space-y-4">
                            <div>
                                <dt class="font-bold text-sky-400">Complete Graph</dt>
                                <dd>A graph where every pair of distinct vertices is connected by a unique edge. In the TSP, this means there is a direct path from every city to every other city.</dd>
                            </div>
                            <div>
                                <dt class="font-bold text-sky-400">Hamiltonian Cycle (or Tour)</dt>
                                <dd>A path in a graph that visits each vertex *exactly once* and returns to the starting vertex. This is the 'tour' the salesperson is looking for.</dd>
                            </div>
                            <div>
                                <dt class="font-bold text-sky-400">Permutation</dt>
                                <dd>An arrangement of items in a specific order. For TSP, each possible tour is a permutation of the cities. The number of permutations of $n$ items is $n!$ (n-factorial).</dd>
                            </div>
                            <div>
                                <dt class="font-bold text-sky-400">Factorial ($n!$)</dt>
                                <dd>The product of all positive integers less than or equal to $n$. ($n! = n \times (n-1) \times ... \times 1$). This function grows *extremely* fast, much faster than $2^n$.</dd>
                            </div>
                        </dl>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Event Listeners
        document
          .getElementById("tsp-verify-btn")
          .addEventListener("click", verifyTSP);
        document
          .getElementById("tsp-solve-btn")
          .addEventListener("click", solveTSP);

        // Wire up tab switching
        setupTabs("tsp-container");

        // Wire up generators
        const citiesText = document.getElementById("tsp-cities");
        document.getElementById("tsp-gen-5").addEventListener("click", () => {
          citiesText.value = generateRandomCities(5);
        });
        document.getElementById("tsp-gen-8").addEventListener("click", () => {
          citiesText.value = generateRandomCities(8);
        });
        document.getElementById("tsp-gen-9").addEventListener("click", () => {
          citiesText.value = generateRandomCities(9);
        });
      }

      function getDist(cityA, cityB) {
        return Math.sqrt((cityA.x - cityB.x) ** 2 + (cityA.y - cityB.y) ** 2);
      }

      function verifyTSP() {
        const output = document.getElementById("tsp-output");
        try {
          const cities = JSON.parse(
            document.getElementById("tsp-cities").value
          );
          const tourInput = document.getElementById("tsp-tour").value;
          const tour = tourInput
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean);

          if (tour.length < 2)
            throw new Error("Tour must have at least 2 cities.");
          if (tour[0] !== tour[tour.length - 1])
            throw new Error("Tour must start and end at the same city.");

          let totalDist = 0;
          let opCount = 0;
          for (let i = 0; i < tour.length - 1; i++) {
            opCount++;
            const cityA = cities[tour[i]];
            const cityB = cities[tour[i + 1]];
            if (!cityA || !cityB)
              throw new Error(`Invalid city: ${tour[i]} or ${tour[i + 1]}`);
            totalDist += getDist(cityA, cityB);
          }

          output.className =
            "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
          output.innerHTML = `<strong>VERIFIED:</strong> Tour: ${tour.join(
            " -> "
          )}<br>Total Length: ${totalDist.toFixed(
            2
          )}<br>(~${opCount} operations, P-time)`;
        } catch (e) {
          output.className =
            "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
          output.textContent = `Error: ${e.message}`;
        }
      }

      function solveTSP() {
        const output = document.getElementById("tsp-output");
        output.className =
          "mt-4 p-4 bg-yellow-900 text-yellow-200 rounded-lg min-h-[50px]";
        output.textContent =
          "Solving (brute force)... This will be very slow if n > 9.";

        setTimeout(() => {
          try {
            const cities = JSON.parse(
              document.getElementById("tsp-cities").value
            );
            const cityNames = Object.keys(cities);
            const n = cityNames.length;

            if (n > 9) {
              output.className =
                "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
              output.textContent = `Error: Too many cities (n=${n}). n > 9 will crash your browser with O(n!) complexity. This is the lesson!`;
              return;
            }

            const startCity = cityNames[0];
            const otherCities = cityNames.slice(1);

            let shortestDist = Infinity;
            let shortestTour = [];
            let opCount = 0;

            // A simple but inefficient permutation generator
            function* getPermutations(arr) {
              if (arr.length === 0) {
                yield [];
                return;
              }
              const first = arr[0];
              const rest = arr.slice(1);

              for (const p of getPermutations(rest)) {
                for (let i = 0; i <= p.length; i++) {
                  opCount++; // Count permutations as operations
                  const start = p.slice(0, i);
                  const end = p.slice(i);
                  yield [...start, first, ...end];
                }
              }
            }

            // A more efficient permutation generator (Heap's Algorithm)
            function* permute(arr) {
              const n = arr.length;
              const c = new Array(n).fill(0);
              let a = [...arr];

              yield a; // Yield the initial array

              let i = 1;
              while (i < n) {
                if (c[i] < i) {
                  const k = i % 2 === 0 ? 0 : c[i];
                  [a[i], a[k]] = [a[k], a[i]]; // Swap
                  c[i]++;
                  i = 1;
                  opCount++;
                  yield a;
                } else {
                  c[i] = 0;
                  i++;
                }
              }
            }

            for (const perm of permute(otherCities)) {
              let currentDist = 0;
              const currentTour = [startCity, ...perm, startCity];

              for (let i = 0; i < currentTour.length - 1; i++) {
                const cityA = cities[currentTour[i]];
                const cityB = cities[currentTour[i + 1]];
                currentDist += getDist(cityA, cityB);
              }

              if (currentDist < shortestDist) {
                shortestDist = currentDist;
                shortestTour = currentTour;
              }
            }

            output.className =
              "mt-4 p-4 bg-green-900 text-green-200 rounded-lg min-h-[50px]";
            output.innerHTML = `<strong>SOLVED:</strong> Shortest Tour: ${shortestTour.join(
              " -> "
            )}<br>Length: ${shortestDist.toFixed(
              2
            )}<br>(~${opCount} permutations checked, $O(n!)$)`;
          } catch (e) {
            output.className =
              "mt-4 p-4 bg-red-900 text-red-200 rounded-lg min-h-[50px]";
            output.textContent = `Error: ${e.message}`;
          }
        }, 50);
      }

      // --- Module 5: Open Problems ---
      function showOpenProblems() {
        const template = `
                <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 4: Open Problems & The Future</h2>
                <p class="text-lg text-gray-300 mb-6">
                    Complexity theory is not a "solved" field. It's an active area of research with
                    some of the deepest, most difficult questions in all of computer science.
                    Click on the <span class="bg-blue-700 text-blue-100 px-2 py-1 rounded-md text-sm">Define</span> tags to learn more.
                </p>
                
                <div class="space-y-8">
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">1. Is P = NP?</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Is every problem that can be *verified* quickly also *solvable* quickly?
                            <br>Formally: Does $\\text{P} = \\text{NP}$?
                            <br><br>
                            This is the most famous problem in computer science. The consensus is that **P $\\neq$ NP**, but proving it remains one of the hardest challenges ever conceived.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">2. Is NP = co-NP?</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** If a problem's "yes" answers are easy to verify, are its "no" answers also easy to verify?
                            <br>Formally: Does $\\text{NP} = \\text{co-NP}$?
                            
                            <details class="popover-def">
                                <summary>Define: co-NP</summary>
                                <div>
                                    <strong class="text-white">co-NP</strong> is the class of problems where "no" instances have a short, verifiable proof (a "counterexample").
                                    <br><br>
                                    <strong>Example: TAUTOLOGY.</strong> Is this Boolean formula *always* true? A "no" answer is an assignment that makes it *false*. We can verify that counterexample quickly.
                                </div>
                            </details>
                            <br><br>
                            If NP $\\neq$ co-NP (which is widely believed), it would imply that proving something is *always* true is fundamentally harder than proving it's *sometimes* true (SAT). It would also prove P $\\neq$ NP.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">3. The Exponential Time Hypothesis (ETH)</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Does the 3-SAT problem *really* require exponential time to solve?
                            
                            <details class="popover-def">
                                <summary>Define: Sub-exponential Time</summary>
                                <div>
                                    <strong class="text-white">Sub-exponential Time</strong> is faster than $O(2^{\\delta n})$ for all $\\delta > 0$, but slower than $O(n^k)$.
                                    <br><br>
                                    ETH claims you can't even get a "mildly" exponential algorithm like $O(2^{\\sqrt{n}})$ for 3-SAT. You're stuck with "strong" exponential time.
                                </div>
                            </details>
                            <br><br>
                            P vs. NP just asks if there's a *polynomial* algorithm. ETH makes a stronger claim: that 3-SAT *requires* a "strong" exponential-time $O(2^{\\delta n})$ algorithm.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">4. Is P = PSPACE?</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Can every problem solvable with *polynomial memory* also be solved in *polynomial time*?
                            
                            <details class="popover-def">
                                <summary>Define: PSPACE</summary>
                                <div>
                                    <strong class="text-white">PSPACE</strong> is the set of problems solvable with a *polynomial* amount of memory, regardless of time.
                                    <br><br>
                                    Think of a chess-solving AI. It might take exponential time, but it only needs to store the current board state ($O(n^2)$ space).
                                </div>
                            </details>
                            <br><br>
                            We know $\\text{P} \\subseteq \\text{NP} \\subseteq \\text{PSPACE}$. We strongly believe $\\text{P} \\neq \\text{PSPACE}$.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">5. Is BPP = BQP? (Quantum)</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Can quantum computers solve problems that classical computers can't?
                            
                            <details class="popover-def">
                                <summary>Define: BPP & BQP</summary>
                                <div>
                                    <strong class="text-white">BPP:</strong> Problems solvable by a *classical* randomized algorithm in P-time.
                                    <br><br>
                                    <strong class="text-white">BQP:</strong> Problems solvable by a *quantum* algorithm in P-time.
                                </div>
                            </details>
                            <br><br>
                            Shor's algorithm for **integer factorization** is in BQP but is *not* believed to be in BPP. If $\\text{BPP} \\neq \\text{BQP}$, it proves quantum computers have a fundamental speedup.
                        </p>
                    </div>
                    
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">6. The Status of Integer Factorization</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Can we factor a large number into its primes in polynomial time (on a classical computer)?
                            
                            <details class="popover-def">
                                <summary>Define: NP-Intermediate</summary>
                                <div>
                                    <strong class="text-white">NP-Intermediate</strong> are problems in NP that are neither in P nor NP-Complete.
                                    <br><br>
                                    They are "hard," but not the "hardest." A fast solver for factoring *would not* mean a fast solver for SAT. Their existence relies on P $\\neq$ NP.
                                </div>
                            </details>
                            <br><br>
                            This is the problem that underpins almost all modern cryptography (like RSA). It's in NP, but not believed to be in P or NP-Complete. (It is, however, in BQP).
                        </p>
                    </div>
                    
                    <div>
                        <h3 class="text-2xl font-semibold text-gray-200 mb-2">7. The Status of Graph Isomorphism</h3>
                        <p class="text-gray-300 leading-relaxed">
                            **The Question:** Can we efficiently determine if two graphs are identical (just with the nodes labeled differently)?
                            
                            <details class="popover-def">
                                <summary>Define: Quasi-polynomial Time</summary>
                                <div>
                                    <strong class="text-white">Quasi-polynomial Time</strong> is $O(2^{(\\log n)^c})$.
                                    <br><br>
                                    This is *much* faster than exponential ($O(2^n)$) but slightly slower than any true polynomial ($O(n^k)$).
                                </div>
                            </details>
                            <br><br>
                            This is another famous "NP-Intermediate" candidate. In 2015, a "quasi-polynomial" time algorithm was announced, strongly suggesting it is *not* NP-Complete, but it's still not known to be in P.
                        </p>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Close other popovers when one is opened
        document.querySelectorAll("details.popover-def").forEach((detail) => {
          detail.addEventListener("toggle", (e) => {
            if (e.target.open) {
              document
                .querySelectorAll("details.popover-def[open]")
                .forEach((openDetail) => {
                  if (openDetail !== e.target) openDetail.open = false;
                });
            }
          });
        });
      }

      // --- NEW Module 6: Reductions ---
      function showReductions() {
        const template = `
                <div id="reductions-container">
                    <h2 class="text-3xl font-bold mb-4 text-sky-400">Module 5: Reductions (Independent Set)</h2>
                    
                    <!-- Tab Buttons -->
                    <div class="flex space-x-2 mb-4">
                        <button class="tab-btn active" data-tab="reduction-what-is">What is a Reduction?</button>
                        <button class="tab-btn" data-tab="reduction-demo">Demo: IS $\\leftrightarrow$ VC</button>
                    </div>

                    <!-- Tab Content: What is a Reduction? -->
                    <div id="reduction-what-is" class="tab-content active bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">What is a Polynomial-Time Reduction?</h3>
                        <p class="mb-4">
                            A **reduction** is a way to solve one problem using an algorithm for *another* problem.
                            A polynomial-time reduction ($L \\le_p L'$) is a "fast" transformation that turns an instance
                            of problem $L$ into an instance of problem $L'$.
                        </p>
                        
                        <h4 class="text-lg font-semibold mb-2">Why do this?</h4>
                        <ol class="list-decimal list-inside space-y-2 mb-4">
                            <li><strong>To Solve Problems:</strong> If you have a "magic" (fast) solver for problem $L'$, you can now use it to solve problem $L$ for free.</li>
                            <li><strong>To Prove Hardness:</strong> This is the big one. If we know $L$ is "hard" (e.g., NP-Complete), and we can reduce $L$ to $L'$, then $L'$ must *also* be "hard".</li>
                        </ol>
                        
                        <p class="mb-2">Formally, a problem $L$ is reducible to $L'$ ($L \\le_p L'$) if there's a P-time
                        function $f$ that converts any instance $x$ of $L$ into an instance $f(x)$ of $L'$ such that:</p>
                        <p class="p-4 bg-gray-900 rounded-lg text-cyan-300">
                            $$x \\in L \\iff f(x) \\in L'$$
                        </p>
                        <p class="mt-2">(The answer to $x$ for problem $L$ is "yes" **if and only if** the answer to $f(x)$ for problem $L'$ is "yes".)</p>
                    </div>
                    
                    <!-- Tab Content: Demo -->
                    <div id="reduction-demo" class="tab-content bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2">Demo: Independent Set $\\leftrightarrow$ Vertex Cover</h3>
                        <p class="mb-4">
                            Let's show a simple reduction between two problems. This will prove they are
                            equally hard and that their optimization problems are linked.
                        </p>
                        
                        <h4 class="text-lg font-semibold mb-2">1. Define: Independent Set (IS)</h4>
                        <p class="mb-2">An **Independent Set** is a set of vertices $S \\subseteq V$ in a graph $G=(V,E)$
                        such that no two vertices in $S$ are connected by an edge.</p>
                        <p class="mb-4 p-4 bg-gray-900 rounded-lg text-cyan-300">
                            $$S \\subseteq V \\text{ s.t. } \\forall (u, v) \\in E, \\{u, v\\} \\not\\subseteq S$$
                        </p>
                        <p class="mb-4">The *decision* problem (NP-Complete) is: "Does $G$ have an independent set of size $k$ or more?"</p>
                        
                        <h4 class="text-lg font-semibold mb-2">2. The "Aha!" Moment: The Reduction</h4>
                        <p class="mb-4">Look at the definitions of Vertex Cover (Module 2) and Independent Set. They are "mirror images" of each other. The reduction is based on this beautiful theorem:</p>
                        
                        <div class="p-4 bg-green-900 text-green-200 rounded-lg mb-4">
                            <strong>Theorem:</strong> In any graph $G=(V,E)$, a set $S \\subseteq V$ is an **Independent Set**
                            if and only if its complement, $V \\setminus S$, is a **Vertex Cover**.
                        </div>
                        
                        <h4 class="text-lg font-semibold mb-2">Proof (Part 1: IS $\\implies$ VC)</h4>
                        <ol class="list-decimal list-inside space-y-2 mb-4">
                            <li><strong>Assume:</strong> $S$ is an Independent Set.</li>
                            <li><strong>We must show:</strong> Its complement $C = V \\setminus S$ is a Vertex Cover.</li>
                            <li><strong>Proof:</strong> Take any edge $(u, v) \\in E$. Since $S$ is an IS, $u$ and $v$ *cannot* both be in $S$.</li>
                            <li>This means at least one of them *must not* be in $S$.</li>
                            <li>If at least one of $\{u, v\}$ is *not* in $S$, then at least one of them *must* be in its complement, $C$.</li>
                            <li>Since this is true for *every* edge, $C$ "covers" all edges. **Therefore, $C = V \\setminus S$ is a Vertex Cover.**</li>
                        </ol>

                        <h4 class="text-lg font-semibold mb-2">Proof (Part 2: VC $\\implies$ IS)</h4>
                        <ol class="list-decimal list-inside space-y-2 mb-4">
                            <li><strong>Assume:</strong> $C$ is a Vertex Cover.</li>
                            <li><strong>We must show:</strong> Its complement $S = V \\setminus C$ is an Independent Set.</li>
                            <li><strong>Proof:</strong> Take any two vertices $u, v \\in S$. We must show there is no edge between them.</li>
                            <li>Assume for contradiction that there *is* an edge $(u, v) \\in E$.</li>
                            <li>Because $C$ is a VC, it must cover this edge. This means at least one of $u$ or $v$ *must* be in $C$.</li>
                            <li>But this is a contradiction! We *chose* $u$ and $v$ from $S$, which is $V \\setminus C$. By definition, neither can be in $C$.</li>
                            <li>The contradiction means our assumption was wrong. There is no edge $(u,v)$. **Therefore, $S = V \\setminus C$ is an Independent Set.**</li>
                        </ol>
                        
                        <h4 class="text-lg font-semibold mb-2">Conclusion</h4>
                        <p>This proves $\\text{Independent Set} \\le_p \\text{Vertex Cover}$ (and vice-versa). It also means $|MaxIS| + |MinVC| = |V|$.
                        <br><br>
                        The brute-force $O(2^n)$ algorithm in **Module 2** that finds a *minimum vertex cover*
                        is, by this reduction, *also* an algorithm for finding a *maximum independent set*. You just
                        take the complement of its answer!</p>
                    </div>
                </div>
            `;
        document.getElementById("module-content").innerHTML = template;

        // Wire up tab switching
        setupTabs("reductions-container");
      }

      // --- Initialization ---

      // Setup nav link listeners
      document.querySelectorAll("nav a").forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          const moduleName = e.currentTarget.dataset.module;
          showModule(moduleName);
        });
      });

      // Show home module on initial load
      window.onload = () => showModule("home");
    </script>
  </body>
</html>
